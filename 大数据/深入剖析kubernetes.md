[TOC]


# 深入剖析kubernetes



## 容器技术入门

### 进程
* 容器的核心功能，通过约束和修改进程的动态表现，从而为其创造出一个“边界”
* Cgroups技术用来制造约束
* Namespace技术用来修改进程视图
* 容器其实是一种特殊的进程

### 隔离与限制

#### Namespace
* 实际上修改了应用进程看待整个计算机’视图‘

##### 优点（相较于虚拟机）
* 敏捷
* 高性能

##### 缺点
* 隔离得不彻底
* 多个容器共享一个宿主操作系统内核
* 有很多资源和对象是不能被Namespace化的


#### Cgroups
* 用来为进程设置资源限制
* 限制一个进程组能够使用的资源上限（CPU、内存、磁盘、网络带宽）


### 容器镜像
* 挂载在容器根目录上，用来为容器进程提供隔离后执行环境的文件系统
* 别名为rootfs

#### rootfs
* 只是一个操作系统所包含的文件、配置和目录
* 不包括操作系统内核

#### 一致性
* rootfs中打包的是整个操作系统的文件和目录
* 应用以及其运行所需要的所有依赖，都封装在了一起

#### 层
* 用户制作镜像的每一步操作，都会生成一个层，即一个增量rootfs
* 使用了联合文件系统的能力，将多个不同位置的目录联合挂载到同一个目录下

#### 结构
* 只读层，挂载方式：readonly + whiteout
* 可读写层，容器最上面的一层，挂载方式：read write
* init层，内部层，用于保存特定的配置信息


### 容器云

#### 视图
* 静态视图（容器镜像）：一组联合挂载的rootfs
* 动态视图（容器运行时）：一个由Namespace + Cgroups构成的隔离环境

#### 要点
* 作为开发者并不关心容器运行时的差异，真正承载着容器信息进行传递的是容器镜像
* 作为云计算提供商通过容器镜像，可以和潜在用户直接关联起来

#### Kubernetes
* 容器编排工具：按照用户的意愿和整个系统的规则，完全自动化地处理容器之间的关系
* 使用’声明式API'来描述容器化业务和容器间的关系



## 容器编排

### 容器特征
* 单进程模型：容器没有管理多个进程的能力


### Pod
#### 实现原理
* 是一个逻辑概念
* 是一组共享了某些资源的容器
* 所有容器共享一个Network Namespace, 和一个Volume
* 有一个Infra容器用于保持住Network Namespace

##### 特征
* 容器可以直接使用localhost进行通信
* 容器看到的网络设备跟Infra容器一致
* 一个Pod只有一个IP地址
* 所有网络资源，一个Pod只有一份，容器共享
* 生命周期只跟Infra容器一致


#### 设计模式
* sidecar：在Pod中，启动一个辅助容器，来完成一些独立于主容器之外的工作

##### war包与web服务器
1. 分别将war包和tomcat分别做成镜像
2. 将war包镜像定义成Init Container类型
3. 使用/app来共享war包

##### 日志收集
1. 应用把日志输出到容器的/var/log目录中
2. 把Pod的volume挂载到/var/log目录上
3. 运行一个sidecar容器，读取日志转发到MongoDB


#### 角色
* Pod 扮演的是传统部署环境里“虚拟机”的角色
* Pod 还可以看成是传统环境里的’机器‘，容器可以看作是‘机器’里面的‘用户程序’

#### 属性 
##### Pod级别
* 调度、网络、存储，以及安全相关的属性
* 和容器的 Linux Namespace 相关的属性
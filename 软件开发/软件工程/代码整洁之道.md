


# 代码整洁之道


## 整洁代码

* 读与写花费时间的比例超过10 ：1
* 写新代码时，我们一直在读旧代码
* 如果每次签入时，代码都比签出时干净，那么代码就不会腐坏



## 有意义的命名

### 避免使用编码
* 不要编码数据类型
* 不要使用 m 前缀来标明成员变量
* 不要用 I 开头来标明是接口


### 命名规则
* 类名和对象名应该是 **名词** 或者 **名词短语**
* 方法名应该是 **动词** 或者 **动词短语**
* 给每个抽象概念选一个词，并一以贯之
* 使用解决方案领域的名字（只有程序员才会读你的代码）
* 提供有意义的语境：使用良好的类名、函数名、名字空间、名字前缀


## 函数
* 要短小
* 只做一件事 （同一抽象层上的多个步骤也算）
* 每个函数一个抽象层级
* 分离指令函数和查询函数
* 使用异常替换返回码
* 抽离 try/catch 代码块  （与主体部分抽离，另外形成函数）

### 命名
* 长且有描述性的名字 **要好于** 短且令人费解的名字
* 长且有描述性的名字 **要好于** 长且有描述性的注释
* 命名方式要保持一致

### 参数
* 个数最好是零，其次是一个，再次是两个，应避免三个
* 如果带标识参数，则应该把函数分成多个
* 一个参数时 函数名和参数名应该形成一个良好的 **动词/名词对**
* 应避免使用输出参数（可以变换成修改对象的状态）

### 步骤
1. 实现函数
2. 打磨函数（分解函数、修改名字、消除重复）
3. 组装函数


## 注释

### 要点
* 别给糟糕的代码加注释，重新写吧
* 注释恰当的用法是弥补我们在用代码表达意图时遭遇的失败


### 好注释

**唯一真正好的注释就是想办法不去写的注释**

* 法律信息
* 提供信息 （更好的方式是利用函数名来传达信息）
* 对意图的解释
* 警告信息
* TODO注释
* 公共API的javadoc


### 坏注释

* 日志式注释
* 循规式注释 （每个函数都要有javadoc）
* 归属和署名
* 注释掉的代码
* 非公共代码中的javadoc
* HTML注释（注释中的HTML标识）


## 格式

### 概述
* 代码格式关乎沟通，而沟通是专业开发者的头等大事
* 好的软件系统由一系列读起来不错的代码文件组成，需要拥有一致和顺畅的分格


### 垂直格式

#### 总体
* 源文件名字应该简单且一目了然
* 源文件最顶部应该给出高层次概念和算法
* 源文件的细节应该往下渐次展开

#### 概念区隔
* 每个空白行都是一条线索，标识出新的独立概念
* 靠近的代码行，则暗示它们之间的紧密关系

#### 具体实施

**目的：建立一种自顶向下的贯穿源代码模块的良好信息流**

* 变量声明：尽可能靠近其使用的位置
* 实体变量：在类的顶部声明
* 相关函数：若有调用关系，就应该放在一起。调用者应该尽可能放在被调用者上面


### 横向格式

* 函数调用中的参数使用空格隔开，表示相互分离
* 对于低优先级的运算符，可以将运算项用空格隔开，表示优先级比较低



## 对象和数据结构的对立性

**对于面向对象较难的事，对于过程式代码却比较容易**

### 对象

#### 优点
* 对象暴露行为、隐藏数据
* 便于添加新对象类型而无需修改既有行为
* 难以在既有对象中添加方法

#### 缺点
* 面向对象代码难以添加新函数(必须修改所有类)

### 数据结构

#### 优点
* 暴露数据，没有明显的行为
* 便于向既有数据结构中添加新行为
* 难以向既有函数中添加新数据结构

#### 缺点
* 过程式代码难以添加新数据结构（必须修改所有函数）



## 错误处理

**错误处理很重要，但是不要搞乱了代码逻辑**

* 使用异常而非返回码
* 先写try-catch-finally语句
* 使用不可控异常（可控异常会违反开放/闭合原则）
* 给出异常发生的环境说明（用于判断错误的来源和出处）
* 依据调用者需要定义异常类（考虑一次如何被捕获）
* 别返回null值（可以抛出异常或返回特例对象）


## 单元测试

### TDD三定律
1. 在编写失败的单元测试前，不要编写生产代码
2. 只编写刚好无法通过的单元测试
3. 只编写刚好足以通过当前失败测试的生产代码


### 保持测试整洁
* 测试代码和生产代码一样重要
* 脏测试等同于无测试（测试必须随生产代码的演进而修改）
* 测试都可以分成三个步骤：构造测试数据、操作测试数据、校验操作是否得到期望的结果
* 测试代码标准：简单、精悍、足具表达力


## 整洁测试规则

* 快速（Fast）：测试应该能快速执行
* 独立（Independent）：测试应该相互独立
* 可重复（Repeatable）：测试应当可在任何环境中重复通过
* 自足验证（Self-Validating）：测试应当能自己验证成功还是失败
* 及时（Timely）：测试应当及时编写



## 系统

### 构造和使用分开

#### 要点
* **软件系统应将启动过程和之后的运行时逻辑分隔开**

#### 方法
* 分解main：将启动过程放入main中
* 抽象工厂：让应用自行控制何时创建对象
* 依赖注入

### 扩容

#### 关键
* 持续的将关注面恰当地切分

#### 步骤
* 只是想今天的用户故事
* 然后重构
* 明天再扩展系统，实现新的用户故事

#### AOP（面向方面编程）

**AOP是一种对横贯式关注面进行模块化的普适手段**

##### 工具
* java代理 
* 纯java AOP框架 ： Spring AOP
* AspectJ语言

#### 测试驱动架构

**最佳的系统架构由模块化的关注面组成，每个关注面均使用java对象实现**

* 优化决策：模块化和关注面切分成就了分散化管理和决策，使决策分散和延后
* 优秀的DSL : 填平领域概念和实现代码之间的 壕沟


## 迭代

### 目标
* **通过迭代设计使代码整洁**

### 简单设计原则
* 运行所有测试：有了测试就可以递增式地重构代码
* 不可重复
* 表达程序员意图：代码具有表达力
* 尽可能减少类和方法的数量

### 表达力
* 选择好的名字
* 保存函数和类短小
* 采用标准命名法
* 良好的单元测试
* 不停尝试

## 并发编程

**并发是一种解耦策略：将 做什么 和 何时做 分解开**

### 中肯说法
* 并发会在性能和代码上增加一些开销
* 正确的并发是复杂的，即便对于简单的问题
* 并发缺陷并非总能重现
* 并发常常需要对设计策略进行根本性修改

### 并发防御原则
* 单一权责：分离并发相关代码和其他代码 
* 限制数据作用域：严格限制对可能被共享的数据的访问
* 线程独立：尝试将数据分解到可被独立线程操作的独立子集中



## 总结

### 注释
* 注释应该只描述有关代码和设计的技术性信息
* 注释应该谈及代码自身没有提及的东西
* 不要注释代码，删除它

### 环境
* 支持一步构建出系统
* 支持一步运行全部的单元测试

### 函数
* 函数的参数量应该少（没有最好，一个次之，三个最多）
* 不要使用输出参数
* 不要使用标识参数（意味着做了不止一件事）
* 删除不再被调用的函数

### 一般性问题
* 源文件只包含一种语言
* 实现其他程序员有理由期待的行为 （最小惊异原则）
* 不要忽视编译警告和静态检查错误
* 尽可能找到并消除重复
* 正确抽象层级：所有较低层级概念放在派生类中，所有较高层级概念放在基类中





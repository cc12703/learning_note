
# 哈夫曼编码是什么

* https://www.baseclass.io/huffman-coding/


## 概述
* 哈夫曼编码算法是很多压缩算法的构件块，像DEFLATE - 用于PNG图片和GZIP格式中


## 为什么要关注
你曾经是否有想知道以下的问题
* 如何在不损失任何数据的情况下压缩某些东西
* 为什么一些东西比其他更好压缩
* GZIP的原理是什么


## 5分钟或更少
* 设想你想压缩一个字符串（哈夫曼编码可以用于任何数据，但是字符串是一个好的用于讲解的例子）
* 不可避免的，在压缩文本过程中，一些字符会比其他字符出现的次数更多
* 哈夫曼编码就是使用了这个事实带来的优点，通过使使用最多的字符占用最少的空间来编码文件


### 编码字符串
接下来让我们使用哈夫曼编码来压缩一句Yoda大师的名言：'do or do not'
* 'do or do not'一共12个字符，包含一些重复字符，所以对压缩来说相当友好
* 为了便于讨论，我们假设一个字符使用8位来存储，这个句子一共需要96位，使用哈夫曼编码可以占用的更少


#### 编码树
* 我们首先构建一棵树
    * 最常用的字符会最接近树根
    * 离树根最远的节点表示不常用的字符
* 'do or do not'的树结构
    ![](https://gitee.com/cc12703/figurebed/raw/master/img/20210507135818.png)
* 在例子字符串中，最常用的字符是'o'(出现4次)和空格(出现3次)
* 注意到，从树根到这两个字符的路径只有两步，而最不常用的字符是三步
* 现在，我们存储到字符的路径来代替字符本身

#### 进行编码
* 我们从树根开始，沿着树向下到达我们需要编码的字符，经过左边路径就存储一个0，经过右边路径就存储一个1
* 首个字符'd'的编码
    ![](https://gitee.com/cc12703/figurebed/raw/master/img/20210507140835.png)
    * 编码后的结果是1、0、0，一共三位，比起之前的8位是一个很大的提升了
* 整个字符串的编码
    ![](https://gitee.com/cc12703/figurebed/raw/master/img/20210507140958.png)
    * 编码后一共29位，而且没有数据损失，太棒了


### 解码字符串
* 为了解码文本，我们只需要沿着每个0(左分支)或1(右分支)直到到达一个字符
* 我们写下字符，并从树根再次开始
* 解码过程
    ![](https://gitee.com/cc12703/figurebed/raw/master/img/20210507141326.png)


### 发送编码后文本
* 但是，当我们给其他人发送编码后文件时，对方难道不需要编码树吗
    * 需要的，对方需要一颗完全相同的哈夫曼编码树才能正确地解码出文本
* 最简单的，也是效率最差的方式就是将编码树附加在压缩文本后一起发送
* 我们也可以先认同一颗树，使用这棵树去编码、解码任何字符串
    * 在我们可以提前预知字符的距离时，这种方式可以很好的工作
* 我们可以在编码特定东西前就构造一个相对有效率的树
* 另一钟方案就是发送足够的信息给对方，让其可以构建出一颗和我们一样的树（GZIP就是这么做的）
    * 例如：我们可以发送每个字符出现的总次数
    * 这个方案必须要很小心，因为**相同的文本块可能可以构建出多棵哈夫曼编码树**
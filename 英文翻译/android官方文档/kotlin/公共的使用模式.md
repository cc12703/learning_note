

# 公共的使用模式

* https://developer.android.com/kotlin/common-patterns

[TOC]


## 在fragments中使用

### 继承
* 可以使用class关键字在kotlin中定义类
* 例子中 LoginFragment 是一个 Fragment 的子类
* 可以在子类和父类之间使用冒号操作符 ：来表示继承关系
    * 例子：
        ```kotlin
        class LoginFragment : Fragment()
        ```
* 在该类的定义中，LoginFragment有责任调用父类Fragment的构造函数
* 在LoginFragment中，你可以覆写生命周期回调函数来响应Fragment的状态变动
    * 可以使用override关键字来覆写一个方法
    * 例子：
        ```kotlin
        override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
        ): View? {
            return inflater.inflate(R.layout.login_fragment, container, false)
        }
        ```
* 可以使用super关键词来引用父类中的函数
    * 例子：
        ```kotlin
        override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
            super.onViewCreated(view, savedInstanceState)
        }
        ```


### 可空性和初始化
* 在前面的例子中，覆写方法中的部分参数会在类型后面带一个问号符号
    * 这表示传给这些参数的数据有可能是空的
* 在kotlin中，你必须在定义对象时就初始化对象的属性
    * 这意味着，当你拿到一个类的实例后，就能马上引用任何可访问的属性
* 一个Fragment中的View对象，会直到Fragment#onCreateView被调用后才能准备好
    * 你需要一种方法来延迟View属性的初始化
* lateinit就可以延迟属性的初始化，在使用了lateinit后，你需要尽快的初始化这些属性
    * 例子：
        ```kotlin
        class LoginFragment : Fragment() {

            private lateinit var usernameEditText: EditText
            private lateinit var passwordEditText: EditText
            private lateinit var loginButton: Button
            private lateinit var statusTextView: TextView

            override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                super.onViewCreated(view, savedInstanceState)

                usernameEditText = view.findViewById(R.id.username_edit_text)
                passwordEditText = view.findViewById(R.id.password_edit_text)
                loginButton = view.findViewById(R.id.login_button)
                statusTextView = view.findViewById(R.id.status_text_view)
            }
            ...
        }
        ```
    * 注意，如果在初始化前就访问这些属性，Kotlin会抛出UninitializedPropertyAccessException



### SAM转换
* 在android中你可以通过实现OnClickListener接口来监听点击事件
    * Button对象就包含一个setOnClickListener()方法，接收一个OnClickListener的实现
* OnClickListener包含一个你必须要实现的抽象方法 onClick()
    * 因为setOnClickListener()经常接收一个OnClickListener作为参数
    * 又因为OnClickListener经常只有一个抽象方法，在Kotlin中可以使用一个匿名函数来表示
    * 这个过程被称为单一抽象方法转换 或者 SAM转换
* SAM转换可以使代码更简洁、清楚
* 例子：
    ```kotlin
    loginButton.setOnClickListener {
        val authSuccessful: Boolean = viewModel.authenticate(
                usernameEditText.text.toString(),
                passwordEditText.text.toString()
        )
        if (authSuccessful) {
            // Navigate to next screen
        } else {
            statusTextView.text = requireContext().getString(R.string.auth_failed)
        }
    }
    ```

### 伴生对象
* 伴生对象提供一种用于定义连接到类型的变量或函数的机制
* 伴生对象非常像给变量和函数使用Java中的static关键字
* 例子：
    ```kotlin
    class LoginFragment : Fragment() {

        ...

        companion object {
            private const val TAG = "LoginFragment"
        }
    }
    ```
* 你可以将TAG定义在文件的顶层，但是文件中还会有大量的定义在顶层的变量、函数和类
* 伴生对象可以在不引用任何特定类实例的情况下，帮助连接变量、函数和类定义



### 属性委托
* 在初始化属性时，你也许会重复一些android上非常通用的模式，像在Fragment中访问ViewModel
* 为了避免大量的重复代码，我们可以使用Kotlin的属性委托语法
* 例子：
    ```kotlin
    private val viewModel: LoginViewModel by viewModels()
    ```
* 瘦数学委托提供了一个可以在应用中各个部分都能复用的通用实现
* KTX提供了一些可用的属性委托
    * 像viewModels，获取一个作用范围只在当前Fragment的ViewModel对象
* 属性委托使用了反射，对性能会有一点点影响
    * 好处就是一个简单的语法可以节约开发时间




## 可空性
### 概述
* Kotlin提供了严格的可空性规则来在整个应用中维护类型安全
* 在Kotlin中引用一个对象默认时不能包含null值的
    * 如果要给一个变量分配一个null值，就需要在基本类型后面增加一个问号来定义一个可空变量
* 例子：
    ```kotlin
    val name: String = null  //这个是非法的表达式
    val name: String? = null
    ```

### 互操作性


### 平台类型

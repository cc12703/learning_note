


# 第二十一章_性能优化

[TOC]


## 记录集的预取模式

### 概述
* 当从数据集中获取记录时，实际上就是对数据库发起一次查询
* 如果数据集中有多条记录，在其中读取记录会使系统变慢，因为会有多次SQL查询


### 如何操作
#### 例子1
##### 正确预取
* 示例代码
```python
def compute_method(self) :
    for rec in self:
        print(rec.name)
```
* 该方法是一个正常的计算方法，self表示有多条记录的记录集
* 当直接遍历记录集时，预取会正常工作

#### 例子2
##### 不正确预取
* 示例代码
```python
def some_action(self) :
    record_ids = []
    self.env.cr.execute("some query to fetch record id")
    for rec in self.env.cr.fetchall():
        record = self.env['res.partner'].browse(rec[0])
        print(record.name)
```
* 该方法使用browse方法来读取数据，在for循环中一个一个的读取记录
* 这时候并没有有效的使用预取，仍然会导致多次查询

##### 正确预取
* 示例代码
```python
def some_action(self):
    record_ids = []
    self.env.cr.execute("some query to fetch record id")
    record_ids = [ rec[0] for rec in self.env.cr.fetchall() ]

    recordset = self.env['res.partner'].browse(record_ids)
    for record_id in recordset:
        print(record.name)
```
* 通过给browse方法传入一个ID的列表，你可以创建一个有多条记录的记录集
* 在该记录集上执行操作，预取会正常工作
* 使用这种方法，你不会丢失预取特性，数据会在一个SQL查询中获取



### 工作原理
* 当在有多条记录的记录集中工作时，预取可以减少SQL查询的个数
    * 通过一次获取全部的数据来达到的
    * 通常情况下，预取会自动执行，但是在某些情况下会丢失该功能
    * 例如像以下代码的那样分隔记录
        ```python
        recs = [r for r in recordset r.id not in [1,2,4,10]]
        ```
* 正确的使用预取可以显著的提升ORM库的性能

#### 工作方式
* 当通过for循环遍历记录集时，并在第一次迭代中读取了一个字段的值，预取操作就会启动
* 预取操作会一次读取所有的记录
* 依赖的逻辑是：如果你在fo循环中读取字段了，你很有可能会继续读取下一条记录的数据
* 预取会一次读取所有记录并将其保存在缓存中，在循环的下一次迭代时，数据会直接从缓存获取

#### 例子
* 设想一个有10条记录的记录集
* 当你在循环的第一个迭代中读取记录的name字段时，预取会读取所有的10条记录
* 预取并不只读取name字段，而是会读取所有10条记录的所有字段
* 在循环的接下来的迭代中，数据会直接从缓存获取
* SQL查询次数会从10次下降到1次
* 代码
    ```python
    for record in recordset :  #记录集有10条记录
        record.name   #在首次迭代时，预取全部10条记录
        record.email  #email的数据将从缓存中获取
    ```
* 注意，预取获取所有的字段（除了*2many字段），会包括哪些在for循环中没有使用的字段
    * 因为相比于为每个字段执行一次查询，额外的列只会对性能有少许的影响


#### 注意
* 有时候，预取的字段会降低性能
* 这个时候，可以通过在上下文中将prefetch_fields设置为False来禁止预取
    ```python
    recordset.with_context(prefetch_fields=False)
    ```

#### 缓存
* 预取机制使用环境缓存来存储、检索记录值
    * 意味着，一旦从数据库中预取了记录，所有的字段的子操作将会使用系统缓存
* 可以通过env.cache属性来读取环境缓存
* 可以使用invalidate_cache()来无效掉缓存



### 更多
#### 拆分记录集
* 当你拆分记录集时，ORM库会使用新的预取上下文来生成一个新记录集
* 在该记录集上执行的操作只能预取各自独立的记录
* 如果你想预取所有的记录，需要将预取记录ID传给with_prefetch()方法
* 示例
    ```python
    recordset = ... #假设记录集有10条记录
    recordset1 = recordset[:5].with_prefetch(recordset._ids)
    recordset2l = recordset[5:].with_prefetch(recordset._ids)
    ```
* 这样预取上下文将不会限制在分离的记录集上
* 你也可以使用with_prefetch()来在多个记录集之间共享一个公共的上下文
    * 意味着：当你从一个记录中读取数据时，也会为其他记录集读取数据
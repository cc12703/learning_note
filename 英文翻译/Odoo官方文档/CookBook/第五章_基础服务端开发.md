

# 第五章_基础服务端开发

[TOC]


## 上报错误给用户


### 总述
* 在方法执行过程中，由于用户请求的动作无效或者遇到一个错误条件而导致过程中断
* 遇到这种情况时，需要显示一个错误信息


### 如何操作
例子：通过修改change_state方法，当用户改变到一个is_allowed_transition方法不允许的状态时，显示一个提示信息
1. 导入系统模块
    ```python
    from odoo.exceptions import UserError
    form odoo.tools.translate import _
    ```
1. 修改chagne_state方法，抛出UserError异常
    ```python
    def change_state(self, new_state) :
        for book in self:
            if book.is_allowed_transition(book.state, new_state) :
                book.state = new_state
            else :
                msg = _('xxxxx')
                raise UserError(msg)
    ```


### 工作原理
* 在Python中当一个异常被抛出时，它会沿着堆栈传播直到被处理
* 在Odoo中，处理所有网页客户端调用的RPC层会捕获所有的异常，根据异常类型，对客户端触发不同行为
* 任何不定义在odoo.exceptions中的异常都会被作为内部服务器错误处理（HTTP状态为500）
* UserError会在用户界面上显示错误信息

#### 字符串翻译
* 例子中我们使用一个定义在odoo.tools.translate包中的特别奇怪名字的函数 _()
* 该函数用于将字符串标记为可翻译的，在运行时会使用终端用户使用的语言来检索翻译后的字符串


#### 重点
* 当使用_()函数时，需要确保只传入插值占位符字符串，而不是整个字符串
    * 例子：_("Warning: could not find %s") % value 是正确的
    * _("Warning: could not find %s" % value) 是错误的



### 更多
#### 自定义错误
* 有时候你会工作在一段容易产生错误的代码中
* Odoo会捕获错误并显示一个堆栈信息给用户
* 如果你不希望给用户显示全部的错误日志，可以捕获这个错误并抛出一个自定义的带有意义信息的异常
* 例子：通过try..cache捕获错误，并抛出UserError
    ```python
    def post_to_webservice(self, data) :
        try:
            req = requests.post('xxx', data=data, timeout=10)
            content = req.json()
        except IOError:
            error_msg = _('xxxx')
            raise UserError(error_msg)
    ```

#### 异常类型
* 在odoo.exceptions包中定义了一些异常类
* 这些类都是派生于基础的exept_orm异常类

##### ValidationError
* 当模型字段的约束条件没有被遵守时，该异常会抛出

##### AccessError
* 当用户访问一些没有权限的数据时，会自动生成该错误
* 如果你想在代码中显示访问错误时，可以手动抛出该异常

##### RedirectWarning
* 这个错误，可以在错误信息中显示一个重定向按键
* 需要传入两个参数：动作ID、错误信息





## 从其他模型获取一个空记录集


### 总述
* 在写Odoo代码时，通过self可以调用当前模型的方法
* 如果你需要调用其他模型，是没有方法直接实例化其他模型的类
* 你需要从该模型中获取一个记录集来开始后面的工作


### 如何操作
1. 在LibraryBook中加入get_all_library_members
    ```python
    clas LibraryBook(models.Model) :

        def log_all_library_members(self) :
            library_memeber_model = self.env['library.member']
            all_members = library_member_model.search([])
            return True
    ```
1. 在from视图中加入按键触发该方法
    ```xml
    <button name="log_all_libraray_memebers" string="Log Memebers" type="object">
    ```

### 工作原理
* 系统启动时，Odoo会加载所有的模块、合并各种派生于Model的类（包括定义的模型和扩展的模型）
* 所有类都会存储在odoo注册表中，使用名字进行索引
* 所有记录集的env属性，类似于self.env，都是位于doo.api模块的Environment类的一个实例


#### Environment类
* Environment在Odoo开发中扮演着一个中心角色
* 通过模拟成一个Python字典，提供了对注册表的快捷访问
    * 如果你知道模型名字，使用self.env[model_name]可以获取到该模型的一个空数据集
    * 该数据集会共享self的环境
* 该类包含一个cr属性
    * 是数据库的游标，可以用来执行一次原始的SQL查询操作
* 该类包含一个user属性
    * 对当前用户的一个引用
* 该类包含一个context属性
    * 一个字典，包含了这次调用的上下文信息
        * 用户的语言、时区、当前选中的记录




## 创建新记录

### 总述
* 在写业务逻辑时，会有一个常见需求就是创建新记录


### 前提
* 需要了解要创建记录的模型的结构，特别是字段的名字和类型，字段上存在的约束


### 如何操作
1. 在library.book.category模型中创建create_categories方法
    ```python
    def create_categories(self) :
        ....
    ```
1. 在方法内，准备一个字典包含字段名和字段值
    ```python
    categ1 = {
        'name': 'xxxx',
        'description': 'xxxx'
    }
    categ2 = {
        'name': 'xxxx',
        'description': 'xxxx'
    }
    parent_category_val = {
        'name': 'xxx', 
        'email': 'xxxx',
        'child_ids': [
            (0,0,categ1),
            (0,0,categ2),
        ]
    }
    ```
1. 调用create方法创建新记录
    ```python
    record = self.env['library.book.category'].create(parent_category_val)
    ```
1. 在form视图上增加按键触发该方法
    ```xml
    <button name="create_categories" string="Create Categories" type="object">
    ```


### 工作原理
* 要一个模型的创建记录，可以在任何关联该模型的记录集上调用create(values)方法
    * 该方法会返回一个长度为1的新记录集，包含了新的记录
    * 字段的值来源于values字典：键为字段名，值为字段对应的值
    * 值依赖于字段类型


#### 不同类型的值
* Text：使用Python字符串
* Float，Integer：使用Python的浮点和整型
* Boolean：使用Python的布尔值和整型
* Date：使用Python的datetime.date对象
* Datetime：使用Python的datetime.datetime对象
* Binary：需要使用Base64编码后的字符串
    * 调用base64模块的encodebytes(bytestring)方法
* Many2one：使用整型，是关联记录的一个数据库ID
* One2Many, Many2Many：使用一个特殊语法，一个包含三个元素的列表
    * (0,0,dict_val) 创建一个新记录并关联到主记录中
    * (6,0,id_list) 在已创建记录和已存在记录之间创建关联



### 更多
* 如果模型的某些字段定义了默认值，不需要做特殊操作
    * create()会为那些没有值字典中出现的字段计算默认值
* create方法也支持批量创建多个记录，值需要传入一个值列表即可
    ```python
    categ1 = {
        'name': 'xxxx',
        'description': 'xxxx',
    }
    categ2 = {
        'name': 'xxx', 
        'description' : 'xxx',
    }
    multiple_records = self.env['library.book.category'].create([categ1, categ2])
    ```
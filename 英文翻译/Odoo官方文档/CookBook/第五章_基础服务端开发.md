

# 第五章_基础服务端开发

[TOC]


## 上报错误给用户


### 总述
* 在方法执行过程中，由于用户请求的动作无效或者遇到一个错误条件而导致过程中断
* 遇到这种情况时，需要显示一个错误信息


### 如何操作
例子：通过修改change_state方法，当用户改变到一个is_allowed_transition方法不允许的状态时，显示一个提示信息
1. 导入系统模块
    ```python
    from odoo.exceptions import UserError
    form odoo.tools.translate import _
    ```
1. 修改chagne_state方法，抛出UserError异常
    ```python
    def change_state(self, new_state) :
        for book in self:
            if book.is_allowed_transition(book.state, new_state) :
                book.state = new_state
            else :
                msg = _('xxxxx')
                raise UserError(msg)
    ```


### 工作原理
* 在Python中当一个异常被抛出时，它会沿着堆栈传播直到被处理
* 在Odoo中，处理所有网页客户端调用的RPC层会捕获所有的异常，根据异常类型，对客户端触发不同行为
* 任何不定义在odoo.exceptions中的异常都会被作为内部服务器错误处理（HTTP状态为500）
* UserError会在用户界面上显示错误信息

#### 字符串翻译
* 例子中我们使用一个定义在odoo.tools.translate包中的特别奇怪名字的函数 _()
* 该函数用于将字符串标记为可翻译的，在运行时会使用终端用户使用的语言来检索翻译后的字符串


#### 重点
* 当使用_()函数时，需要确保只传入插值占位符字符串，而不是整个字符串
    * 例子：_("Warning: could not find %s") % value 是正确的
    * _("Warning: could not find %s" % value) 是错误的



### 更多
#### 自定义错误
* 有时候你会工作在一段容易产生错误的代码中
* Odoo会捕获错误并显示一个堆栈信息给用户
* 如果你不希望给用户显示全部的错误日志，可以捕获这个错误并抛出一个自定义的带有意义信息的异常
* 例子：通过try..cache捕获错误，并抛出UserError
    ```python
    def post_to_webservice(self, data) :
        try:
            req = requests.post('xxx', data=data, timeout=10)
            content = req.json()
        except IOError:
            error_msg = _('xxxx')
            raise UserError(error_msg)
    ```

#### 异常类型
* 在odoo.exceptions包中定义了一些异常类
* 这些类都是派生于基础的exept_orm异常类

##### ValidationError
* 当模型字段的约束条件没有被遵守时，该异常会抛出

##### AccessError
* 当用户访问一些没有权限的数据时，会自动生成该错误
* 如果你想在代码中显示访问错误时，可以手动抛出该异常

##### RedirectWarning
* 这个错误，可以在错误信息中显示一个重定向按键
* 需要传入两个参数：动作ID、错误信息





## 从其他模型获取一个空记录集


### 总述
* 在写Odoo代码时，通过self可以调用当前模型的方法
* 如果你需要调用其他模型，是没有方法直接实例化其他模型的类
* 你需要从该模型中获取一个记录集来开始后面的工作


### 如何操作
1. 在LibraryBook中加入get_all_library_members
    ```python
    clas LibraryBook(models.Model) :

        def log_all_library_members(self) :
            library_memeber_model = self.env['library.member']
            all_members = library_member_model.search([])
            return True
    ```
1. 在from视图中加入按键触发该方法
    ```xml
    <button name="log_all_libraray_memebers" string="Log Memebers" type="object">
    ```

### 工作原理
* 系统启动时，Odoo会加载所有的模块、合并各种派生于Model的类（包括定义的模型和扩展的模型）
* 所有类都会存储在odoo注册表中，使用名字进行索引
* 所有记录集的env属性，类似于self.env，都是位于doo.api模块的Environment类的一个实例


#### Environment类
* Environment在Odoo开发中扮演着一个中心角色
* 通过模拟成一个Python字典，提供了对注册表的快捷访问
    * 如果你知道模型名字，使用self.env[model_name]可以获取到该模型的一个空数据集
    * 该数据集会共享self的环境
* 该类包含一个cr属性
    * 是数据库的游标，可以用来执行一次原始的SQL查询操作
* 该类包含一个user属性
    * 对当前用户的一个引用
* 该类包含一个context属性
    * 一个字典，包含了这次调用的上下文信息
        * 用户的语言、时区、当前选中的记录




## 创建新记录

### 总述
* 在写业务逻辑时，会有一个常见需求就是创建新记录


### 前提
* 需要了解要创建记录的模型的结构，特别是字段的名字和类型，字段上存在的约束


### 如何操作
1. 在library.book.category模型中创建create_categories方法
    ```python
    def create_categories(self) :
        ....
    ```
1. 在方法内，准备一个字典包含字段名和字段值
    ```python
    categ1 = {
        'name': 'xxxx',
        'description': 'xxxx'
    }
    categ2 = {
        'name': 'xxxx',
        'description': 'xxxx'
    }
    parent_category_val = {
        'name': 'xxx', 
        'email': 'xxxx',
        'child_ids': [
            (0,0,categ1),
            (0,0,categ2),
        ]
    }
    ```
1. 调用create方法创建新记录
    ```python
    record = self.env['library.book.category'].create(parent_category_val)
    ```
1. 在form视图上增加按键触发该方法
    ```xml
    <button name="create_categories" string="Create Categories" type="object">
    ```


### 工作原理
* 要一个模型的创建记录，可以在任何关联该模型的记录集上调用create(values)方法
    * 该方法会返回一个长度为1的新记录集，包含了新的记录
    * 字段的值来源于values字典：键为字段名，值为字段对应的值
    * 值依赖于字段类型


#### 不同类型的值
* Text：使用Python字符串
* Float，Integer：使用Python的浮点和整型
* Boolean：使用Python的布尔值和整型
* Date：使用Python的datetime.date对象
* Datetime：使用Python的datetime.datetime对象
* Binary：需要使用Base64编码后的字符串
    * 调用base64模块的encodebytes(bytestring)方法
* Many2one：使用整型，是关联记录的一个数据库ID
* One2Many, Many2Many：使用一个特殊语法，一个包含三个元素的列表
    * (0,0,dict_val) 创建一个新记录并关联到主记录中
    * (6,0,id_list) 在已创建记录和已存在记录之间创建关联



### 更多
* 如果模型的某些字段定义了默认值，不需要做特殊操作
    * create()会为那些没有值字典中出现的字段计算默认值
* create方法也支持批量创建多个记录，值需要传入一个值列表即可
    ```python
    categ1 = {
        'name': 'xxxx',
        'description': 'xxxx',
    }
    categ2 = {
        'name': 'xxx', 
        'description' : 'xxx',
    }
    multiple_records = self.env['library.book.category'].create([categ1, categ2])
    ```




## 更新记录集中记录的值

### 总述
* 业务逻辑经常会要求我们修改记录中的某些字段的值


### 如何操作
1. 创建change_update_data()方法
    ```python
    def change_update_data(self) :
        self.ensure_one(;
        self.data_release = fields.Date.today()
    ```
1. 在form视图中加入按键
    ```xml
    <button name="change_update_data" string="Update Date" type="object"/>
    ```
1. 重启服务器，更新my_library模块


### 工作原理
* 方法一开始，调用了ensure_one()。会检查数据集中是否只有一条记录
    * 如果不是只有一条，则该方法会抛出异常，操作进程会被中断
    * 这个非常必要，因为你不想改变多个记录的日期
    * 如果你想更新多条记录，可以移除ensure_one(),并在记录集中使用循环来更新属性
* 最后方法修改了记录属性的值，使用当前日期更新了date_release字段
    * 仅仅通过修改记录集的字段数据，你就可以执行写操作


### 更多
向记录的字段中写入新值一共有三个方法

#### 方法1
* 直接给记录属性赋值
* 可以使用在任何场所
* 缺点：不能一次性给记录集中的所有记录赋值
    * 需要对记录集进行遍历操作

#### 方法2
* 使用update()方法，传入一个映射了属性名和值的字典作为参数
* 这个方法也只能用于记录集中只有一条记录的情况
* 当需要在相同记录上立刻更新许多属性的值时，该方法可以节约一些打字的时间
* 例子
    ```python
    def change_update_data(self) :
        self.ensure_one()
        self.update({
            'date_release': fields.Datetime.now(),
            'another_field': 'value'
        })
    ```

#### 方法3
* 使用write()方法，传入一个映射了属性名和值的字典作为参数
* 这个方法可以用于任意大小的记录集，可以在一次数据库操作中使用特定值更新所有记录
* 该方法的限制
    * 如果记录不存，则无法更新
    * 需要使用特殊格式来更新关系属性


##### 特殊格式
| 元组 | 效果 | 
| -- | -- | 
| (0, 0, dict_val) | 创建一条关联到主记录的新记录 |
| (1, id, dict_val) | 使用特定id来更新相关联的记录 |
| (2, id) |  从关联字段中移除特定id的记录，并从数据库中删除 | 
| (3, id)  | 从关联字段中移除特定id的记录，但不从数据库中删除 |
| (4, id) |  将一条已存在的特定id的记录，关联到关联记录的列表中 | 
| (5, ) | 移除所有的关联记录 | 
| (6, 0, id_list)  |  在已更新记录和已存在记录之间创建关联 |

* 注意：操作类型1，2，3，5不能用于create()方法





## 搜索记录


### 如何操作
1. 在library.book模型中增加find_book方法
    ```python
    def find_book(self) : 
        domain = [
            '|', 
                '&', ('name', 'ilike', 'Book Name'), 
                    ('category_id.name', 'ilike', 'Category Name'), 
                '&', ('name', 'ilike', 'Book Name 2'),
                    ('category_id.name', 'ilike', 'Category Name 2'), 
        ]
        books = self.search(domain)
    ```


### 工作原理
* 使用局部变量创建了一个搜索域
    * 通常这种定义是直接在调用search时完成的，但是对于复杂的域，分开定义是一个良好的实践
* 使用域来调用search方法，该方法返回一个包含了所有匹配记录的记录集

#### search方法参数
* offset=N : 用于忽略前N个匹配的记录
    * 该参数经常和limit一起使用，用于数据分页和降低内存消耗
    * 默认值为 0 
* limit=N : 用于标明最多返回N条记录，默认没有限制
* order=字段 : 用于强制对记录集进行排序
    * 默认时，记录集的顺序由模型类的_order属性决定
* count=布尔值 : 返回记录集的数量，不是记录集本身
    * 默认值为False


#### 重点
* 我们推荐使用search_count(domain)，而不是search(domain, count=True)。因为该方法的名字含义更清晰


#### 搜索其他模型
* 为了搜索其他模型，需要从该模型中获取到一个空记录集
* 例子：搜索联系人，需要调用res.partner模型的search()方法
    ```python
    def find_partner(self) : 
        PartnerObj = self.env['res.partner']
        domain = [
            '&', ('name', 'ilike', 'Parth Gajjar'),
                ('company_id', '=', 'Odoo)
        ]
        partner = PartnerObj.search(domain)
    ```


### 更多
* 前面我们说过，search()方法会返回搜索匹配域的记录
* 但是这并没有说全，安全规则会确保我们只能获取哪些有读权限的记录
* 此外如果模型有一个active的布尔属性，搜索域中对该字段没有设置条件
    * 然后添加一个隐式条件去搜索只有active=True的记录
    * 如果你期待该搜索返回一些记录，但是你只得到一个空记录集。就需要去检查记录规则中的active字段的值
* 当你写一个原始SQL查询语言来查找记录ID时
    * 请确保你在获取到ID值后使用以下的语句来确保安全规则被应用
        ```python
        self.env['record.model'].search([('id', 'in', tuple(ids))]).ids
        ```
    * 这个操作对于多公司机制非常重要，因为Odoo会使用记录规则来确保公司之间得到一个正确的区分





## 合并记录集


### 如果操作
1. 合并两个记录集，并保留之前的顺序，需要使用以下操作
    ```
    result = recordset1 + recordset2
    ```
1. 合并两个记录集，并在结果中去除重复项，需要使用以下操作
    ```
    result = recordset1 | recordset2
    ```
1. 查找两个记录集中公共的记录，需要使用以下操作
    ```
    result = recordset1 & recordset2
    ```


### 工作原理
* 记录集的实现类使用了Python的操作符重载


#### 操作符说明
* R1 + R2
    * 会返回一个新记录集，包含了R1中的记录，再加上R2中的记录
    * 会在结果集中产生重复的记录
* R1 - R2 
    * 会返回一个新记录集，包含了哪些在R1中存在，但是不在R2中存在的记录
    * 会保留记录的原来顺序
* R1 & R2 
    * 会返回一个新记录集，里面的记录在R1和R2中都存在（记录集的交集）
    * 不会保留记录的原来顺序，记录不会有重复
* R1 | R2 
    * 会返回一个新记录集，里面的记录要么属于R1，要么属于R2（记录集的并集）
    * 不会保留记录的原来顺序，记录不会有重复
* R1 == R2 
    * 如果两个记录集包含相同的记录，会返回true 
* R1 <= R2 或者 R1 < R2
    * 如果R1中的所有记录是R2的一个子集，会返回true
* R1 >= R2 
    * 如果R1中的记录是R2的一个超集，会返回true
* R1 != R2  
    * 如果R1和R2没有包含相同的记录，会放回true 
* R1 in R2  
    * 如果R1(必须要有一条记录)是R2的一部分，会返回true
* R1 note R2 
    * 如果R1(必须要有一条记录)不是R2的一部分，会返回true

#### 其他操作符
* +=, -=, &=, |= 会修改操作符的左值，替换为一个新的记录集
* 这对于更新记录中的One2many或者Many2many字段特别有用


# 第八章_高级服务端开发技术

[TOC]


## 改变用户来执行操作

### 总述
* 在写业务逻辑时，有时候需要使用不同的安全上下文来执行一些动作
    * 一个典型的例子就是使用superuser权限来执行一个动作，可以忽略所有的安全检查


### 如何操作
1. 在library.book模型中增加book_rent()方法
    ```python
    def book_rent(self) : 
        self.ensure_one()

        if self.state != 'available' :
            raise UserError(_('xxxxxx'))
        
        rent_as_superuser = self.env['library.book.rent'].sudo()
        rent_as_superuser.create({
            'book_id': self.id, 
            'borrower_id': self.env.user.partner_id.id
        })
    ```
1. 在book视图中增加按键触发该方法
    ```xml
    <button name="book_rent" string="Rent this book" type="object" class="btn-primary" />
    ```


### 工作原理
* 使用了sudo()方法，该方法返回一个带有修改后environment的记录集
    * 该环境下用户拥有superuser权限
* 当记录集调用sudo()时，环境会修改environment的su属性，该属性用于标明环境是否有superuser状态
    * 可以通过recordset.env.su来访问该状态
* 通过sudo记录集调用的所有方法都会具有superuser特权
* 如果要使用特定用户，可以给记录集传入该特定用户或者该记录的数据库ID
    ```python
    public_user = self.env.ref('base.public_user')
    public_book = self.env['library.book'].with_user(public_user)
    public_book.search(['name', 'ilike', 'cookbook'])
    ```


### 更多
* 使用sudo()，你可以忽略访问权限和安全记录规则。有时候你需要访问一下被隔离的记录
    * 例子：在多公司环境下，读取别的公司的记录
    * sudo()记录集可以忽略所有的Odoo安全规则
* 如果你不小心，将该环境下获得的记录关联上数据库中的任何公司
    * 意味着你泄漏了信息给用户
    * 更糟糕的是，在不同公司之间关联记录会慢慢的腐蚀掉数据库


#### 重点
* 当使用sudo()时，要多次检查确保你调用search()时，不依赖标准记录规则来过滤结果





## 在已修改的上下文中调用方法

### 总述
* 上下文(context)是记录集环境的一部分，用于传递额外信息（时区、用户语言）
* 可以使用该上下文在动作中传递指定参数
* 在标准Odoo插件中，大量的方法都使用上下文来通过不同的上下文值来适配业务逻辑
* 有时候，需要通过修改记录集的上下文来拿到一次方法调用的期望结果、一个计算属性的期望值


### 如何操作
1. 更新state字段定义，加入lost状态
    ```python
    state = fields.Selection([
        ('ongoing', 'Ongoing'),
        ('returned', 'Returned'),
        ('lost', 'Lost'),
    ])
    ```
1. 在界面增加 标记为丢失 的按键
    ```xml
    <button name="book_lost" string="Lost the Book" states="ongoing" type="object"/>
    ```
1. 在模型library.book.rent中增加book_lost()方法
    ```python
    def book_lost(self) :
        self.ensure_one()
        self.sudo().state = 'lost'

        book_with_different_context = self.book_id.with_context(avoid_deactivate=True)
        book_with_different_context.sudo().make_lost()
    ```
1. 修改模型library.book中的make_lost()方法
    ```python
    def make_lost(self) :
        self.ensure_one()
        self.state = 'lost'

        if not self.env.context.get('avoid_deactivate') :
            self.active = False
    ```


### 工作原理
#### 步骤1
* 给书增加了已新状态，用于标明书已经丢失

#### 步骤2
* 页面上增加一个新按键，用于用户上报丢失书

#### 步骤3
* 增加一个方法，当用户点击丢失书按键后被调用
* 使用了参数调用self.book_id.with_context()，会返回book_id记录集带修改后上下文的新版本
* 这里只加入一个键avoid_deactivate=True，但是你可以加入任意多个键值
* 最后使用了sudo()，可以使用非图书管理员的用户也可以上报书丢失

#### 步骤4
* 检查上下文中是否包含有avoid_deactivate的正值
* 我们防止释放该书，可以使图书管理员看见书已经丢失了


#### 结果
* 当图书管理员从页面上报丢失书时，书记录的状态会变成lost，书会被归档
* 但是单非图书管理员在他们的借阅记录中上报丢失书时，书记录的状态不会变成lost
    * 书不会被归档，图书管理员就可以看见进行处理



### 更多
* 给with_context()传入一个字典也是可以的
    * 这时候，字典信息会被作为新的上下文而覆盖掉当前的上下文
    * 例子：
        ```python
        new_context = self.env.context.copy()
        new_context.update({'avoid_deactivate' : True})

        book_with_different_context = self.book_id.with_context(new_context)
        book_with_different_context.make_lost()
        ```






## 定义基于SQL视图的模型

### 总述
* 当我们开发插件模块时，我们用于建模数据的类会被odoo的ORM库映射为数据库中的表
* 我们会使用一些众所周知的设计原则：关注点分离、数据标准化
* 但是在模块设计的最后阶段，将多个模型的数据聚合到一张表中、对其执行一些操作是非常有用的
    * 特别是上报或者生成仪表板
* 为了使上面的步骤更简单，也是为了能发挥出PostgreSQL数据库引擎的所有能力，依赖PostgreSQL视图而不是表来定义一个只读的模型是合理的


### 如何操作
1. 创建一个模型类，_auto属性设置为False
    ```python
    class LibraryBookRentStatistics(models.Model) :
        _name = 'library.book.rent.statistics'
        _auto = False
    ```
1. 在模型中定义需要的字段，并设置为只读
    ```python
    book_id = fields.Many2one('library.book', string='Book', readonly=True)
    rent_count = fields.Integer(string="Times borrowed", readonly=True)
    ```
1. 定义init函数用于创建视图
    ```python
    def init(self) : 
        tools.drop_view_if_exists(self.env.cr, self._table)
        query = """
                CREATE OR REPLACE VIEW
            library_book_rent_statistics AS (
                SELECT
                    min(lbr.id) as id,
                    lbr.book_id as book_id,
                    count(lbr.id) as rent_count,
                FROM
                    library_book_rent AS lbr
                JOIN
                    library_book as lb ON lb.id = lbr.book_id
                WHERE
                    lbr.state = 'returned'
                GROUP BY lbr.book_id
            );
            """
        self.env.cr.execute(query)
    ```
1. 为新模型创建视图
1. 不要忘记定义访问规则



### 工作原理
#### 步骤1
* 正常情况下，Odoo为用字段定义列的方式，来为我们定义的模型创建数据库表
    * 因为在BaseModel类中，_auto属性默认值为True
* 在该步骤中，我们通过将该属性设置为False，告知Odoo我们自己来管理表的创建

#### 步骤2
* 我们会定义一些Odoo用于生成表的字段
* 我们需要小心地将它们都标记为readonly=True，这样视图就不会启用修改
    * 因为PostgreSQL视图是只读的，无法将其进行保存

#### 步骤3
* 定义init方法
* 该方法正常情况不需要做任何事情，在_auto_init()运行后被调用
* 这里我们使用该函数来创建一个SQL视图（在模块更新时，更新已存在的视图）
* 视图创建语句中使用的列名必须匹配模型中的字段名



### 更多
* 在一些模型中总会出现计算字段和关联字段，仅有的限制就是这些字段不能被存储
    * 所以你就无法使用这些字段来分组记录和搜索记录






## 添加自定义设置项


### 总述
* Odoo中，你可以通过设置项来提供可选择的特性
* 用户可以在任何时刻，打开、关闭这些选项


### 如何操作
1. 在my_library/security/groups.xml增加新权限组
    ```xml
    <record id="group_self_borrow" model="res.groups">
        <field name="name">Self borrow</field>
        <field name="users" eval="[(4, ref('base.user_admin'))]" />>
    </record>>
    ```
1. 继承模型res.config.settings，并增加新字段
    ```python
    class ResConfigSettings(models.TransientModel) : 
        _inherit = 'res.config.settings'

        group_self_borrow = fields.Boolean(string="Self borrow", 
                        implied_group="my_library.group_self_borrow")
    ```
1. 在设置界面使用xpath添加字段
    ```xml
    <record id="res_config_settings_view_form" model="ir.ui.view">
        <field name="name">res.config.settings.view.form.inherit.library</field>
        <field name="model">res.config.settings</field>
        <field name="inherit_id" ref="base.res_config_settings_view_form"></field>
        <field name="arch" type="xml"/>
            ...
        </field>
    </record>
    ```
1. 给设置菜单，添加一个菜单项和多个动作
    ```xml
    <record id="library_config_settings_action" model="ir.actions.act_window">
        <field name="name">Settings</field>
        <field name="type">ir.actions.act_window</field>
        <field name="res_model">res.config.settings</field>
        <field name="view_id" ref="res_config_settings_view_form"></field>
    </record>
    <menuitem
        id="library_book_setting_menu"
        name="Settings"
        action="library_config_settings_action"
        parent="library_base_menu"
        sequence="10"/>
    ```
1. 在book视图上修改按键，并加入my_library.group_self_borrow组
    ```xml
    <button name="book_rent"
           string="Rent this book"
           type="object" class="btn-primary"
           groups="my_library.group_self_borrow"/>
    ```


### 工作原理
* 在Odoo中，所有的设置选项都在res.config.settings模型中。
* res.config.settings是一个瞬时的模型
* Odoo设置都使用一个窗体视图来显示所有设置项
    * 外部ID为base.res_config_settings_view_form

#### 步骤1
* 创建一个安全组，使用它来隐藏和显示按键

#### 步骤2
* 给res.config.settings模型增加一个布尔字段
* 给该字段增加一个值为my_library.group_self_borrow的implied_group属性
    * 当管理员使能和禁止这个布尔选项时，这个安全组将会分配给所有用户、从所有用户中移除

#### 步骤3
* 通过继承设置视图，加入我们自己的设置项



### 更多
#### 使用方法1
* 将功能分离到新模块中，通过选项来安装、卸载它们
* 使用带前缀module_的模块名字来添加一个布尔属性
    ```python
    module_my_library_extras = fields.Boolean(string="Library Extra Features")
    ```
* 当我们使能、禁止该选项时，Odoo会安装、卸载这个my_library_extras模块


#### 使用方法2
* 使用系统参数，数据将会存储在ir.config_parameter模型中
    ```python
    digest_emails = fields.Boolean(string="Digest Emails"
                config_parameter="digest.default_digest_emails")
    ```
* config_parameter属性将会把用户数据存储在系统参数区域
    * 菜单项：设置 -> 技术 -> 参数 -> 系统参数
    * 数据将用digest.default_digest_emails键来保存


### 总结
* 设置项用于使你的应用更通用
* 设置项给了用户自由选择权，可以允许他们在线的使能、禁止功能特性
* 当你将一个功能特性转换成设置项时，你就可以使用一个模块来服务更多的顾客
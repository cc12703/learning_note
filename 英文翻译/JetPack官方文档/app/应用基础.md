

# 应用基础

* 原始文档：https://developer.android.com/guide/components/fundamentals

[TOC]


## 总体

### 概述
* 可以使用Kotlin, Java, C++语言来编写android应用程序
* SDK工具会将代码连同数据和资源文件一起编译成一个apk文件
* apk文件是一个android包，后缀名是.apk，格式为压缩包
* 一个apk文件包含了一个应用的所有内容，该文件可以在任何一个android支持的设备上进行安装

### 应用沙箱
每个应用都运行在自己的安全沙箱中，由以下安全特性进行保护
* 操作系统是一个多用户的Lisnux系统，每个应用都是一个不同用户
* 默认情况下系统会被每个应用分配一个唯一的Linux用户标识(操作系统使用该标识，对应用而言是未知的)
* 系统会给应用中的所有文件设置好权限，保证只有该应用才能读取这些文件
* 每个进程都有属于自己的虚拟机(VM)，所有每个应用的运行代码都是独立于其他应用的
* 默认情况下，每个应用都运行在自己的Linux进程中
    * 当应用的任何一个组件需要执行时，系统就会启动进程
    * 当应用的任何一个组件都不在需要时，系统会关闭进程
    * 当系统需要为其他应用腾出内存时，也会关闭进程


### 最小特权原则
* 默认情况下，每个应用都只能访问那些被请求过的组件，其他组件都不能访问
* 这些原则会创建一个应用不能访问没有授权的部分的安全的环境
* 应用可以通过以下方式来和其他应用共享数据、访问系统服务

#### 共享方法
* 给两个应用分配一个Linux用户标识是可能的，在这种情况下，这两个应用可以访问彼此的文件
    * 应用使用相同的用户标识，可以运行在同一个进程中，共享一个虚拟机，以节约系统资源
    * 两个应用必须使用相同的签名信息
* 应用可以请求权限来访问设备数据，像：定位、摄像头、蓝牙连接
    * 用户需要明确的允许这些权限




## 应用组件

### 概述
* 应用组件是android应用的必须的构建块
* 每个组件都是一个系统和用户该应用的入口点
* 一个组件会依赖于其他组件
* 组件分为四个类型：Activities，Services，广播接收器，内容提供者
* 每个类型都有不同的目的，有不同的生命周期（组件何时被创建、销毁）


### Activities
#### 定义
* 是一个用于和用户进行交互的入口点
* 表现为一个带有用户界面的单一屏幕

#### 例子
* 一个邮件应用有很多个activity
    * 一个activity用于显示一个新邮件列表
    * 一个activity用于写邮件
    * 一个activity用于阅读邮件
* 通过这些相互之间独立的acivity的协同工作，可以形成一个有粘性的用户体验
* 在获取到邮件应用的许可后，一个其他应用都可以启动这些activity中的任何一个
    * 一个摄像应用可以启动邮件应用中的写邮件activity，来允许用户共享一张图片

#### 简化交互
activity可以让应用和系统之间的交互更简单
* 可以跟踪到用户当前关心什么，保证该activity属于的进程一直运行着
* 可以知道前面运行过的进程包含了一些用户可能会返回的activity，这样系统会以更高的优先级来保持这些进程的存活
* 可以帮助应用处理所属进程被杀死的情况，用户可以返回到这些状态已经恢复的activity
* 可以提供一种在不同应用间实现用户交互流的方法，系统可以协调这些流



### Services
#### 定义
* 是一个保持应用在后台运行的，通用入口点
* 是一个用于在后台执行长时间操作、为其他进程执行工作的组件
* 不提供用户界面
* 其他组件（像activity）可以启动service让其运行，或者绑定它与其交互

#### 例子
* 当用户在其他应用中时，一个service会在后台播放音乐
* 在不阻塞用户和activity交互的情况下，通过网络获取数据


#### 类型
* 实际上存在两种非常不同语境的服务来告诉系统如何管理应用
    * 已启动的服务会告诉系统保持它们运行直到需要的工作完成
    * 工作包括：在后台同步数据、当用户离开应用后继续播放音乐
* 音乐播放是需要用户直接关注的。应用会告诉系统它想成为带通知的前台来让用户感知到
    * 系统知道后，会尽量的保证该服务的进程运行，因为进程消失后用户会不高兴
* 一个正常的后台服务是用户不会直接感知到它在运行的
    * 系统会有更自由的管理这些进程，如果系统需要更多RAM来处理用户关心的事件，这些服务就会被杀死（一段时间会被重启）


#### 绑定
* 绑定功能是为了让其他应用（系统）可以使用别的服务
* 一个服务给其他家进程提供API是很基础的功能
* 如果进程A绑定到进程B中的一个服务，系统就会知道这两个进程间存在依赖。就需要为了进程A保持进程B的运行
* 如果进程A运行的内容是用户关心的，那么进程B也会成为用户关心的。
    * 因为两个进程是关联的（一起好，一起坏）
    * 服务是构建所有高层次的系统概念的一个非常有用的构造块
* 动态壁纸、通知栏监听、截屏、输入法、辅助服务和很多其他核心系统特征都是构建在应用实现的服务上的



### 广播接收器
#### 定义
* 广播接收器是一个可以在正常用户流以外让系统给应用发送事件、允许应用响应系统范围内的匿名广播的组件
* 因为广播接收器是另外一个定义良好的应用入口点，所以系统可以在应用未运行时发送广播事件给应用
    * 应用可以启动一个alarm，发送一通知栏信息，告知一个即将来临的消息给用户
    * 因为alarm可以发送消息给应用的广播接收者，所以应用就不需要一直在后台运行
* 许多广播都是系统发送的
    * 屏幕灭广播
    * 电量低广播
    * 截屏完成广播
* 应用页可以发送广播
    * 让其他应用知道数据已下载完成，可以使用
* 虽然广播接收器不需要显示用户界面，但是当广播事件发生时，可以创建一个状态栏通知告知用户
* 更常见的做法是，广播接收器作为一个进入其他组件的网关，本身只做一点点工作
    * 启动一个JobService，来执行一些操作




### 内容提供者
#### 定义
* 用于管理一个保存在文件系统、SQLite数据库、网站、其他可持久化存储位置的共享应用数据集
* 通过内容提供者，在允许后其他应用就可以查询或则修改其中的数据
* 例子：android系统就提供了一个用户联系人信息的内容提供者
    * 任何有适合权限的应用都可以查询该内容提供者，去读写特定联系人的信息
* 将内容提供者看成是一个数据库的抽象是一个诱人的想法
    * 因为内容提供者内建了很多API用于大部分情况
* 但是如果站在系统设计者的角度看，就会发现存在一个不同的核心用途
    * 对于系统而言，内容提供者是应用的一个用于发布由URI识别的，有名数据项的入口点
* 这样一个应用可以决定如何将其数据映射到URI命名空间，将URI分发给其他可以访问数据的实体

#### 注意点
* 分发一个URI并不需要应用在运行，URI会在所属应用退出后持久存在
    * 系统只需要保证当通过对应URI访问应用数据时，应用正在运行即可
* URI提供一个非常重要的细颗粒度的安全模型
    * 一个应用可以将一个图片的URI放置在剪贴板上，但是将其内容提供者锁定
    * 其他应用就无法自由的访问图片
    * 当第二个应用要访问剪贴板上的URI时，系统可以通过一个临时的URI授权来使应用可以访问数据


### 组件关系
* android的系统有一个独特设计：任何应用都可以启动其他应用的组件
* 例子：如果你想让用户通过设备摄像头拍一张照片，很有可能其他应用已经有了该功能，你的应用就可以直接使用而不用再开发该功能了
    * 你不需要合并摄像头应用的代码，只需要简单的启动摄像头应用拍照的activity即可
    * 当完成后，照片会回到你的应用中，就可以使用了
    * 对于用户而言，摄像头就像是你应用的一部分
* 当系统启动一个组件时，如果应用位运行会先启动进程并实例化组件的类
    * 如果你的应用启动摄像头应用中的activity来拍照，activity是运行在摄像头应用的进程中
    * 所以不像其他系统中的应用，android的应用不会有一个简单的入口点（像main()函数）
* 因为系统会在独立进程中运行每个应用，所带有的文件权限会阻止其他应用的访问
    * 你的应用是无法直接激活其他应用中的组件的
    * 要激活其他应用中的组件，需要发送一个表明你意图的消息给系统来启动特定的组件
    * 系统会为你激活这些组件



### 激活组件

#### 意图
* 四类组件中的三类（activity,service,广播接收器）都可以通过一个称为意图的异步消息来激活
* 在运行时，意图会与一个独立的组件进行绑定
* 你可以将意图想象成一个带有其他组件请求动作的消息，不用管这个组件是你自己应用的，还是其他应用的
* 一个意图是通过创建一个用于激活特定组件（显示意图）、特定类型组件（隐式意图）消息的Intent对象

#### 类型
##### activity和service
* 一个意图定义了一个用于执行的动作（查看某信息、发送某信息）
    * URI上还带有执行所需要的数据，以及要启动的组件
    * 例子：一个意图传达了对一个可显示图片，可打开网页的activity的请求
* 有时候，你可以启动一个activity，来接收一个结果
    * activity会使用intent来返回结果
    * 例子：发起一个意图来让用户选择一个联系人信息，并返回给你。结果意图中就会包含一个指向已选择联系人的URI

##### 广播接收器
* 意图简单定义了一个用于广播的通知
* 例子：一个表明设备电量低的广播，只包含一个字符串来表示电量低

##### 内容提供者
* 不是通过意图来激活的，而是通过一个内容解析器（ContentResolver）的请求来激活的
* 这个内容解析器处理所有和内容提供者的直接传输，组件就不需要再调用内容解析器的方法了
* 相当于在内容提供者和请求内容的组件之间构建了一个抽象层


#### 激活方法
* 对于activity，将一个Intent传给startActivity()或startActivityForResult()
* 对于service
    * android 5.0及其以上可以使用JobScheduler来调度动作
    * 更早的android，将一个Intent传给startService()或bindService()
* 对于广播，将一个Intent传给sendBroadcast(), sendOrderedBroadcast()或sendStickyBroadcast()
* 对于内容提供者，可以调用ContentResolver上的query()



## manifest文件

### 概述
* 在系统启动应用组件前，系统必须要通过读取应用manifest文件（AndroidManifest.xml）来知道组件的存在
* 应用必须在该文件中定义所有的组件，该文件必须在应用工程的根目录下

### 功能
* 标识应用要求的任何用户权限（网络访问、读取用户联系人）
* 基于代码中所有使用的API，定义应用要求的最小API级别
* 定义应用要求的硬件、软件特征（支持摄像头、支持蓝牙、支持多点触摸）
* 定义应用需要链接的API库


### 定义组件
* manifest的首要任务就是告知系统应用的组件
* 使用以下元素来定义应用组件
    * \<activity\> 定义activities
    * \<service\>  定义services
    * \<receiver\> 定义广播接收器
    * \<provider\> 定义内容提供者
* 例子
    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <manifest ... >
        <application android:icon="@drawable/app_icon.png" ... >
            <activity android:name="com.example.project.ExampleActivity"
                    android:label="@string/example_label" ... >
            </activity>
            ...
        </application>
    </manifest>
    ```
    说明
        * 在\<application\>元素中，android:icon属性指向一个用于识别应用的图标资源
        * 在\<activity\>元素中，android:name属性指定一个Activity子类的全限定名，android:label属性使用字符串来给activity指定一个用户可见的标签

#### 注意点
* 如果activity，service，内容提供者只在代码中定义了，而没有在manifest中进行定义，则这些对于系统是不可见，也无法运行
* 对于广播接收器，可以在manifest中定义，也可以在代码中通过BoradcastReceiver对象进行动态创建


### 定义组件能力

#### 原因
* 如前所述，要激活组件，你可以使用意图来启动activity,service,广播接收器
* 可以通过在意图中明确指定目标组件名字的方式来使用意图
* 可以使用一个用于描述要执行动作的类型，以及所需要的数据的隐式意图
* 隐式意图允许系统在设备中查找可以执行动作的组件，并启动它
* 如果存在多个可以执行意图所描述动作的组件，则用户需要从中选择一个


#### 方法
* 系统通过比较接收到的意图和应用manifest中提供的意图过滤器，来识别组件是否可以响应某个意图
* 当在manifest中定义activity时，可以包含一个用于定义activity能力的意图过滤器，这样activity就可以响应来自其他应用的请求了
* 通过在组件定义元素中增加子元素\<intent-filter\>，可以定义意图过滤器


#### 例子
```xml
<manifest ... >
    ...
    <application ... >
        <activity android:name="com.example.project.ComposeEmailActivity">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <data android:type="*/*" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
        </activity>
    </application>
</manifest>
```
说明
* 如果其他应用使用ACTION_SEND动作创建了一个意图，并传给startActivity()，则系统会启动你的activity来让用户编辑并发送邮件


### 定义应用要求

#### 原因
* android支持多种多样的设备，这些设备并不会提供一样的特性和能力
* 为了阻止你的应用被安装在一些缺少应用需要的特性的设备上，通过在manifest文件中声明设备和软件的要求，来清楚的为你的应用所支持的设备定义一个配置信息就显得非常重要了
* 大部分定义都是一些信息，系统是不需要读取的，一些额外服务（Google Play）就需要读取它们来为搜索应用的用户提供一个过滤器


#### 例子
* 应用使用了摄像头，并引入了android 8.0中的API，就需要定义这些请求
    * 在build.gradle文件中
    ```groovy
    android {
        ...
        defaultConfig {
            ...
            minSdkVersion 26
            targetSdkVersion 29
        }
    }
    ```

    * 在manifest文件中
    ```xml
    <manifest ... >
        <uses-feature android:name="android.hardware.camera.any"
                    android:required="true" />
        ...
    </manifest>
    ```
* 以上的定义会导致无摄像头的设备或android系统版本低于8.0的设备无法从Google Play中安装你的应用
* 然而你也可以定义成，应用使用了摄像头但并不强制要求
    * 必须将user-feature中required属性设置成false
    * 在运行时检查设备是否存在摄像头，并在无摄像头时禁止掉相关的功能


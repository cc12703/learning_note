[TOC]


# Docker介绍


## 总体

* 一个开源的应用容器引擎
* 用来管理软件部署，将应用打包成一个镜像
* 一个基于linux内核的，C/S架构的应用程序
* 在linux内核容器技术上，提供了一个更高层的控制工具

### 特征
* 将配置抽象并与应用程序一同打包，提供了跨主机部署的功能
* 提供了一套从源码自动构建生成镜像的工具
* 提供了类似于git的版本管理功能
* 提供了容器重用功能
* 通过仓库可以共享镜像

### vs虚拟机
* 容器和虚拟机是互补的
* 虚拟机是用于硬件资源划分的解决方案
* 容器是操作系统级别的虚拟化，仅仅用于隔离进程本身


### 角色

#### Docker引擎
* 有两个版本：企业版、社区版。
* 由Docker公司开发

#### Moby开源项目
* 目标是发展成为Docker的上游
* 将Docker拆分为更多的模块化组件

#### OCI(开放容器计划)
* 对容器的基础组件进行标准化
* 在Linux基金会的支持下运作
* Docker公司和CoreOS公司都是主要贡献者
* 发布的规范：镜像规范、运行时规范


## 组件

### 概述

* **引擎**: 用于运行和管理容器
* **容器**: 容器以镜像为基础，为镜像提供了一个标准的、隔离的执行环境
* **镜像**: 是轻量化的，分层的，可复用的。 可以通过Dockerfile方式来创建
* **仓库**: 用于集中存放镜像


### 引擎

* client 客户端
* daemon 守护进程
* containerd
* runc

#### runc
* OCI容器运行时规范的参考实现
* 独立的容器运行时工具
* 包装了Libcontainer，提供CLI界面

#### containerd
* 主要功能：容器的生命周期管理
* 将Docker镜像转换为OCI Bundle

#### shim
* **用于实现无daemon的容器**
* 保存所有的stdin, stdou流是开启状态
* 将容器的退出状态反馈给daemon
* containerd-shim进程会成为容器的父进程

#### daemon
* 提供基于版本的REST API


### 镜像

* 由一些松耦合的只读镜像层组成
* Docker负责堆叠这些镜像层，将其表示为单个统一的对象
* 镜像本身是一个配置对象，包含了所有的镜像层和元数据

#### 标识
* 镜像标识是一个加密ID，即配置对象本身的散列值
* 镜像层标识也是一个加密ID，即本身内容的散列值


### 容器

* 操作系统虚拟化
* 共享一个操作系统、内核
* 卷是容器中存储持久化数据的首选方式



## 应用容器化

### 步骤
1. 编写应用代码
2. 创建Dockerfile：应用描述、依赖、如何运行
3. 创建镜像，将程序构建到Docker镜像中



## 网络

### 特点

* 网络模型是建立在network namespace， linux网桥，vxlan隧道，iptables规则之上
* 过渡依赖于linux网桥和iptables，导致效率不高

### 组件

* CNM
* Libnetwork
* 驱动

#### CNM
* CNM: Container Network Model  
* 定义了标准的API用于为容器配置网络，其底层可以适配各种网络驱动
* 基本要素：沙盒、端点、网络

##### 沙盒
* 一个隔离的网络运行环境
* 一个独立的网络栈
* 包括来自多个网络的多个端点

##### 端点(Endpoint)
* 虚拟网络接口
* 用于将沙盒加入一个网络
* 只能属于一个沙盒及一个网络

##### 网络(network)
* 包括一组能互相通信的端点
* 802.1d网桥的软件实现


#### Libnetwork
* CNM的具体实现，被Docker所使用


#### 驱动模式

##### bridge
* 默认的驱动方式。
* 容器通过一对veth pair连接到docker0网桥上，由Docker为容器动态分配IP，路由，防火墙规则

##### host
* 容器与主机共享同一个network namespace

##### null
* 容器内无网络配置

##### remote
* 用于实现网络插件
* 通过HTTP RESTFul API对接第三方的网络方案

##### overlay
* 跨主机多子网的方案
* 通过linux bridge 和 vxlan隧道 来实现


## 数据管理

### 非持久化数据

* 自动创建、从属于容器
* 生命周期与容器相同

### 持久化数据

* 推荐使用卷
* 命令：docker volume xxx



## 安全

* **容器的安全性**：容器是否会危害到host或其他容器
* 镜像的安全性：保证下载的镜像是可信的，未被篡改的
* daemon的安全性：确保命令发送方式可信的用户


### 容器安全性

* **根源是容器和host共用内核，导致攻击面特别大**
* cgroup对系统资源的限制已经比较完善了
* namespace的隔离还不是很完善

### 安全策略

* 目的：赋予容器必要的最小能力

#### 使用cgroup限制
* 限制CPU，内存，块设备IO

#### 使用ulimit
* 设置全局默认的ulimit，对容器单独设置ulimit
* 可以限制进程数据段大小、可创建文件的大小、常驻内存集的大小、打开文件的数量、进程栈的大小、最大线程数等等

#### 容器组网
* 将受信任的和不受信任的容器组网在不同的网络中

#### 容器+全虚拟化
* 将容器运行在全虚拟化的环境中（虚拟机中）


#### 镜像签名
* 使用TUF(Docker的可信镜像及升级框架)


#### 日志审计
* 通过日志驱动将日志从容器输出到日志系统中

#### 监控
* 实时监控容器的资源使用情况

#### 文件系统级防护
* 设置容器的根文件系统为只读模式
* 禁止掉容器里进程remount的能力

#### capability
* Docker启动容器时，会通过白名单的方式来设置容器的capability
* 通过--cap-add, --cap-drop来修改白名单

#### selinux
* 一种MAC控制机制
* 可以在启动daemon时，使用--selinux-enabled=true来打开

#### appArmor
* 一种MAC控制机制
* 可以设置某个可执行程序的访问控制权限

#### seccomp
* secure computing mode  是linux内核提供的安装特性
* 用来实现应用程序的沙盒机制，已白名单、黑名单的方式限制进程的系统调用
* 通过seccomp-bpf可以限制任意的系统调用和传入的参数

##### 步骤
1. 生成BPF形式的过滤规则
2. 调用prctl将规则传入内核




## 集群管理

### 工具

* compose 用来组装多容器应用的工具
* machine 支持多平台安装Docker的工具
* swarm 容器集群管理工具

### compose

* **容器编排工具**
* 使用python开发
* 简化容器镜像的建立和运行
* 使用yml文件来定义多容器应用

#### 使用步骤
1. 用Dockerfile定义应用的运行环境，可以构造出一个镜像
2. 用docker-compose.yml文件定义应用的各个服务
3. 执行docker-compose up来创建和运行整个应用


### machine

* 简化Docker安装的命令行工具
* 一个machine就是一个host主机和经过配置的client的结合体
* 本质是一个框架，对于任何提供虚拟机服务的平台，只要提供对于的驱动就可以使用

#### 执行流程
1. 创建虚拟机并在其上创建一个docker host
2. 使用docker client和host通信，创建镜像，启动容器

### swarm

* Docker社区提供的原生支持Docker集群的工具
* 把多个Docker主机转换成一个单一的虚拟Docker主机
* 具有良好的扩展性

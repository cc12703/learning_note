
# 从0开始学架构
@课程笔记

[TOC]


## 架构是什么

### 理清概念
* 系统和子系统
* 模块和组件
* 框架和架构

### 系统与子系统
* 系统是由一系列有关联，按特定规则组成的个体，并且产生新的能力
* 系统是相互协同可运行的实体
* 系统和子系统则是观察的角度不同

### 模块与组件
* 模块是从逻辑角度去看待系统，是从业务维度上职责的划分
* 组件是从物理角度去看待系统，是从技术维度上的复用

### 框架与架构
* 架构是一种结构，是开放性的，是顶层设计，
* 框架是规范也是约束，是封闭性的，是面向编程，配置的半成品


## 架构的目的

* **为了解决软件系统复杂度带来的问题**

### 架构即决策
* 在一个有约束的盒子里面去求解最合适的解
* 约束：团队经验、成本、资源、进度、业务所处的阶段


## 复杂度的来源

### 高性能
#### 单机复杂度
* 操作系统
* 进程和线程

#### 集群复杂度
* 任务分配
* 任务分解

### 高可用
* **本质通过“冗余”来实现高可用**
* 计算高可用
* 储存高可用


### 可扩展性
* 良好的可扩展性：正确的预测变化、完美的封装变化


### 低成本
* 本质上是和高性能和高可用冲突的，是架构设计的附加约束
* 一般通过”创新“来达到低成本的目标（引入新技术、开创全新的技术领域）

### 安全
* 功能上的安全，”防小偷“
* 架构上的安全，”防强盗“

### 系统规模
* 功能越来越多，导致系统复杂度指数级上升
* 数据越来越多，系统复杂度发生质变


## 架构设计原则

### 合适原则
* **合适优于业界领先**
* 优秀的架构都是在企业当前人力、条件、业务等各种约束下设计出来
* 能够合理的将资源整合在一起并发挥出最大功效，并且能快速落地


### 简单原则
* 简单优于复杂

### 演化原则
* **演化优于一步到位**

#### 演化过程
1. 架构要满足当时的业务需要
2. 架构要不断的在实际应用中迭代
3. 当业务发生变化时，架构要扩展，重构，重写



## 架构设计流程

### 识别复杂度

### 设计备选方案
#### 常见错误
* 设计最优秀的方案
* 只做一个方案
* 备选方案过于详细

#### 正确做法
1. 备选方案以3-5个为最佳
2. 备选方案的差异要比较明显
3. 备选方案的技术不要只局限于已经熟悉的技术
4. 备选方案要关注与技术选型而非技术细节



## 高性能数据库集群

### 读写分离
#### 思路
* **将数据库读写操作分散到不同的节点上**

#### 基本实现
1. 服务器搭建主从集群（一主一从，一主多从）
2. 主机负责读写操作，从机只负责读操作
3. 主机通过复制将数据同步到从机
4. 业务服务器将写操作发送给主机，读操作发送给从机

#### 复制延迟

##### 解决方法
1. 写操作后的读操作指定发送给主机
2. 读从机失败后再读一次主机
3. 关键业务读写操作全部指向主机，非关键业务采用读写分离

#### 分配机制

##### 程序代码封装
* 在代码中抽象一个数据访问层，实现读写操作分离和管理数据库连接

###### 特点
* 实现简单，可以根据业务做定制功能
* 每个编程语言都要实现一次，无法通用
* 故障情况下，则可能需要所有系统都修改配置并重启

###### 产品
* 淘宝的TDDL

##### 中间件封装
* 独立一套系统出来，实现读写操作分离和管理数据库连接。

###### 特点
* 能够支持多种编程语言，对外提供标准的SQL接口
* 实现比较复杂，容易出现BUG
* 对性能要求很高
* 主从切换对业务服务器无感知

###### 产品
* MySQL Router
* Atlas


### 分库分表

#### 原因
**数据量太大会导致单台数据库服务器出现问题**
1. 读写性能下降，即使有索引也会下降
2. 数据文件会很大，数据库备份和恢复时间变长
3. 数据文件越大，极端情况下丢失数据的风险也越高

#### 业务分库
* **按照业务模块将数据分散到不同的数据库服务器**

##### 问题
1. 无法join查询操作
2. 无法通过事务统一修改
3. 带来成本的代价


#### 数据分表
* **对单表的数据进行拆分**

##### 垂直拆分
* 将单表的列分离出去，拆分后记录数量相同
* 用于将表中某些不常用且占用了大量空间的列拆分出去

###### 复杂度
1. 会增加表操作的数量


##### 水平拆分
* 将记录分离出去，拆分后列相同，包含不同的记录
* 用于拆分行数特别大的表，关键要看表的访问性能

###### 路由
* 计算某条数据属于哪个子表
* 算法：
    1. 范围路由
    2. hash路由
    3. 配置路由

###### join操作
* 多次join查询，并将结果合并

###### count()操作
1. 多次count()操作，将结果相加
2. 新建一张表，记录子表中记录的数量

###### order by操作
* 分别查询每个子表中的数据，然后汇总进行排序


## 高性能NoSQL

**NoSQL通过牺牲ACID中的某几个特征，来提高某些方面的性能**

### 关系数据库缺点
* 存储的是行记录，无法存储数据结构
* schema扩展不方便
* 在大数据场景下I/O较高
* 全文搜索功能比较弱


### KV存储
* 解决关系数据库无法存储数据结构的问题
* 代表：Redis

#### 优点
* Value是具体的数据结构，可以直接操作

#### 缺点
* 不支持完整的ACID事务（只保证I和C）


### 文档数据库
* 解决关系数据库强schema约束的问题
* 代表：MongoDB

#### 优点
* 新增加字段简单，无需先执行DDL语句修改结构
* 历史数据不会出错
* 容易存储复杂数据（使用JSON）

#### 缺点
* 不支持事务
* 无法实现关系数据库的join操作


### 列式数据库
* 解决关系数据库大数据场景下I/O较高的问题
* 代表：HBase
* 一般应用于离线的大数据分析和统计场景中

#### 优点
* 同时读取多个列时效率高
* 能够一次性完成对一行中多个列的写操作
* 更高的存储压缩比
* **只有特定的业务场景才能体现，例：海量数据统计**

#### 缺点
* 随机写效率要远远低于行式存储
* 更新数据的效率也比较低



### 全文搜索引擎
* 解决关系数据库全文搜索性能问题
* 代表：Elasticsearch

#### 优点
* 搜索条件可以随意排列组合
* 可以提供模糊匹配方式

#### 使用方式
* 将关系型数据转换为文档数据
* 将关系型数据按照对象的形式转换为JSON文档，将JSON文档输入引擎进行索引


## 高性能缓存架构

### 目的
* 为了弥补存储系统在复杂业务场景下的不足
* 需要经过复杂运算后得出的数据
* 读多写少的数据

### 原理
* 将可能重复使用的数据放入内存中
* 一次生成，多次使用

### 缓存穿透
* 缓存没有发挥作用
* 业务系统去查询缓存，缓存中没有数据，需要再次去存储系统查询数据

#### 情况1
* 原因：数据确实不存在
* 解决方法：直接设置一个默认值存到缓存中

#### 情况2
* 原因：缓存数据生成会耗费大量时间或资源，在缓存失效后的一段时间内还是会去访问存储系统
* 解决方法：没有好的解决方案


### 缓存雪崩
* **当缓存失效后引起系统性能急剧下降的情况**

#### 解决方法：更新锁
* 对缓存更新操作进行加锁保护
* 保证只有一个线程能够进行缓存更新，其他线程可以等待或返回默认值
* 需要用到分布式锁系统

#### 解决方法：后台更新
* 由后台线程来更新缓存，缓存本身有效期设置成永久
* 特殊情况：缓存内存不足，踢掉一些数据，导致数据丢失
    * 解决方法：业务线程发现缓存失效后，通过消息队列发送消息通知后台线程更新


### 缓存热点
* **对于一些特别热点的数据，导致缓存服务器压力变大**
* 解决方法：复制多份缓存副本，将请求分散到多个缓存服务器上
* 注意点：
    * 不同的缓存副本不要设置统一的过期时间，会导致缓存雪崩
    * 一般是设定一个过期时间范围，过期时间在范围内随机




## 单服务器高性能模式
### 目的
* 尽量提升单服务器的性能
* 如果单服务器无法支撑，设计集群方案

### 并发模型
* **单服务器高性能的关键之一**

#### 设计点
* 服务器如何管理连接
* 服务器如何处理请求

#### 系统相关
* I/O模型：阻塞、非阻塞、同步、异步
* 进程模型：单进程、多进程、多线程


### PPC
* Process Per Connection
* 每次都新建一个进程去处理请求

#### 优点
* 实现简单

#### 缺点
* 新建进程代价高
* 父子进程通信复杂
* 支持的并发连接数量有限


### TPC
* Thread Per Connection 
* 每次都新建一个线程去处理请求

#### 优点
* 解决了创建进程代价高
* 解决了进程通信复杂的问题

#### 缺点
* 高并发时还是有性能问题
* 引入线程间互斥和共享的复杂度
* 多线程间会相互影响


### Reactor
* I/O多路复用结合线程池
* 非阻塞的同步网络模型，读写操作都需要用户进程同步操作

#### 核心
* Reactor负责监听和分配事件
* 处理资源池负责处理事件

#### 方案1
* **单Reactor + 单进程/线程**

##### 实现
1. Reactor通过select监听连接事件，通过dispatch进行分发
2. 若是连接事件由Acceptor处理，通过accept接受连接，并创建一个Handler来处理后续的各种事件
3. 若不是连接事件，Reactor会调用对应的Handler来处理
4. Handler会完成 read -> 业务处理 -> send 流程

##### 缺点
* 只有一个进程，无法发挥多核CPU的性能
* Handler容易导致性能瓶颈

#### 方案2
* **单Reactor + 多线程**

##### 实现
1. 主线程中，Reactor通过select监听连接事件，通过dispatch进行分发
2. 若是连接事件由Acceptor处理，并创建一个Handler来处理后续的各种事件
3. 若不是连接事件，Reactor会调用对应的Handler来处理
4. Handler只负责响应事件，不进行业务处理（只读取数据）
5. Processor会在独立子线程中完成业务处理，将结果数据发给Handler处理
6. Handler收到响应后通过send将结果发生给client

##### 缺点
* 多线程数据共享和访问比较复杂
* Reactor承担了所有事件的监听和响应，高并发时会成为性能瓶颈


#### 方案3
* **多Reactor + 多进程/线程**

##### 实现
1. 父进程的主Reactor通过select监听连接事件，将新的连接分配给某个子进程
2. 子进程的次Reactor将该连接加入队列进行监听，并创建一个Handler来处理后续的各种事件
3. 当新事件发生时，次Reactor会调用对应的Handler来进行处理
4. Handler会完成 read -> 业务处理 -> send 流程

##### 优点
* 父进程和子进程的分工非常明确。父进程只负责接收新连接，子进程负责业务处理
* 父进程和子进程的交互很简单
* 子进程之间是相互独立的，无须同步共享的处理

#### 例子
* Nginx采用的是多Reactor+多进程模式
* Memcache, Netty采用的是多Reactor+多线程模式


### Proactor
* **异步网络模型**

#### 实现
* 初始化是创建Proactor和Handler，并通过Async Opera Processor注册到内核
* Async Opera Processor负责处理注册请求，并完成I/O操作
* Async Opera Processor完成I/O操作后通过Proactor
* Proactor根据事件类型回调不同的Handler进行业务处理
* Handler完成业务处理

#### 优点
* 能够充分利用DMA特性，让I/O操作和计算重叠





## 高性能负载均衡
* **高性能集群设计的复杂度主要体现在任务分配部分**

### 分类

#### DNS负载均衡
* 最常见的负载均衡方式
* 一般用于实现地理级别的均衡

##### 优点
* 简单，成本低，由DNS服务器处理
* 就近访问，提升访问速度

##### 缺点
* 更新不及时：DNS缓存时间比较长
* 扩展性差：控制权在域名商
* 分配策略比较简单

#### 硬件负载均衡
* 使用独立的硬件设备来实现均衡，例如：F5, A10

##### 优点
* 功能强大：支持各层级的负载均衡
* 性能强大
* 稳定性高
* 支持安全防护

##### 缺点
* 价格昂贵
* 扩展能力差

#### 软件负载均衡
* 通过负载均衡软件来实现均衡，例如：Nginx, LVS

##### 优点
* 简单：部署，维护都比较简单
* 便宜
* 灵活：可以根据业务进行选择，4层和7层

##### 缺点
* 性能一般
* 功能没有硬件负载均衡那么强大
* 一般不具备安全防护功能


### 架构
* DNS用于实现地理级别的负载均衡
* 硬件用于实现集群级别的负载均衡
* 软件用于实现机器级别的负载均衡


### 算法

#### 类型
##### 任务平分类
* 将收到的任务平均分配给服务器进行处理
* 平均指绝对数量的平均，比例或权重上的平均

##### 负载均衡类
* 根据服务器的负载来进行分配
* 负载指系统当前的压力：CPU负载，连接数、I/O使用率

##### 性能最优类
* 根据服务器的响应事件来进行分配
* 优先将任务分配给响应最快的服务器

##### Hash类
* 根据任务中的关键信息进行hash运算，将相同值的请求分配到同一台服务器上
* 信息：源地址，目标地址，session-id，用户ID


#### 轮询
* 收到请求后，按照顺序轮流分配到服务器上

##### 优点
* 实现简单

##### 缺点
* 太简单，无法感知服务器状态


#### 加权轮询
* 根据服务器权重进行任务分配
* 权重一般是根据硬件配置进行静态配置的

##### 优点
* 解决了不同服务器处理能力有差异的问题

##### 缺点
* 无法根据服务器状态差异进行任务分配


#### 负载最低优先
* 将任务分配给当前负载最低的服务器
* 根据不同的任务类型和场景可以选择不同的指标

##### 指标
1. LVS设备可以使用 ‘连接数’
2. Nginx设备可以用 ‘HTTP请求数’
3. CPU密集型任务可以用 ‘CPU负载’
4. I/O密集型任务可以用 ‘I/O负载’




## CAP理论

### 含义
#### 第一版解释
> 对于一个分布式系统，不可能同时满足一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三个设计约束

#### 第二版解释
> 在一个分布式系统(指相互连接并共享数据的节点集合)中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲


### 设计约束

#### 一致性
##### 含义
* 第一版：所有节点在同一时刻都能看到相同的数据
* 第二版：对于某个客户端，读操作保证能够返回最新的写操作结果

##### 差异点
* 第二版从客户端的角度描述，更加符合我们观察和评估系统的方式
* 第二版从客户端的读写角度来描述一致性，定义更加精确
* 第二版没有强调同一时刻拥有相同数据

#### 可用性
##### 含义
* 第一版：每个请求都能得到成功或失败的响应
* 第二版：非故障的阶段在合理时间内返回合理的响应（不是错误和超时的响应）

##### 差异点
* 第二版强调非故障节点，如果节点故障，发给的请求不一定能得到一个响应
* 第一版的成功和失败定义太泛了，第二版明确了不能超时，不能出错

#### 分区容忍性
##### 含义
* 第一版：出现消息丢失或者分区错误时系统能够继续运行
* 第二版：当出现网络分区后，系统能够继续‘履行职责’

##### 差异点
* 第二版强调功能正常，解释更加明确
* 第一版直接说了部分原因，第二版直接说现象


### 应用
* **分布式理论上不可能选择CA架构，只能选择CP或AP架构**

#### CP
* 为了保证一致性，当发生分区现象后。未更新数据的节点需要给客户端返回错误信息

#### AP
* 为了保证可用性，当发生分区现象后。未更新数据的节点要返回当前的数据


### 关键细节点
* CAP关注的粒度是数据，而不是整个系统
* CAP是忽略网络延时的
* 需要为分区恢复后做准备

#### 实践点
* 需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP还是AP）


### 对比其他理论
#### ACID
* 数据库系统为了保证事务的正确性而提出的一个理论
* Atomicity(原子性)
* Consistency(一致性)
* Isolation(隔离性) 允许多个并发事务同时对数据进行读写、修改
* Durability(持久性) 事务处理结束后，对数据的修改就是永久的

#### BASE
* 核心思想：即使无法做到强一致性，可以采用适合的方式达到最终一致性
* 本质上是对CAP的延伸和补充，对CAP中AP方案的一个补充
* Basically Available(基本可以) 出现故障时，允许损失部分可用性，来保证核心可用
* Soft State(软状态) 允许系统存在中间状态，而该中间状态不会影响系统整体可用性
* Eventual Consistency(最终一致性) 系统中所有数据副本经过一定时间后，最终能够达到一致的状态



## 高可用存储架构
* **本质通过将数据复制到多个存储设备，通过数据冗余来实现高可用**

### 思考点
* 数据如何复制
* 各个节点如何分工
* 如何应对复制延迟（难点）
* 如何应对复制中断（难点）

### 主备复制
* 最常见也是最简单的

#### 实现
* 一个主机，一个备机
* 主机将数据复制到备机
* 备机只起到一个备份作用，不承担读写操作
* 备机改为主机需要人工操作

#### 优点
* **实现简单**
* 客户端不要感知备机的存在
* 对于主机和备机而言，只需要进行数据复制即可

#### 缺点
* 备机仅仅是备份，硬件成本上有浪费
* 故障后需要人工干预，无法自动恢复

#### 适用场景
* 内部的后台管理系统


### 主从复制
#### 实现
* 一个主机，一个从机
* 主机将数据复制到从机
* 从机需要承担读操作
* 从机改为主机需要人工操作

#### 优点
* 主机故障时，读操作可以继续
* 从机提供读操作，发挥了硬件的性能

#### 缺点
* 客户端需要感知主从关系，将不同操作发给不同的机器
* 如果主从复制延迟较大，会出现数据不一致的问题
* 故障后需要人工干预，无法自动恢复

#### 适用场景
* 写少读多的业务，论坛、BBS、新闻网站


### 双机切换

* 为了解决主备复制，主从复制的共同问题而产生的
* 给原方案增加了 ‘切换’ 功能

#### 问题
1. 主机故障后，无法进行写操作
2. 如果主机无法恢复，需要人工操作

#### 思考点
##### 状态判断
* 如何判断状态（相互判断，第三方仲裁）
* 判断那些状态（机器是否掉电、进程是否存在、响应是否缓慢）

##### 切换决策
* 切换时机（什么情况下备机升级为主机）
* 切换策略 （主机恢复后是否需要再次切换，还是作为新备机）
* 自动程序 （全自动，半自动）

##### 数据冲突解决

#### 互连式
##### 实现
1. 主机和备机增加一个‘状态传递’的通道
2. 在备机无法获取到主机状态时，将自己升级为主机
3. 客户端需要特殊处理

##### 缺点
* 如何状态传输通道故障，会出现双主机的情况

#### 中介式
##### 实现
1. 在主备机之外引入第三方中介
2. 主备机都连接中介
3. 由中介来传递状态信息

##### 优点
###### 连接管理更简单
* 主备机无须建立连接通道，只要连接到中介即可

###### 状态决策更简单
* 无论主机还是备机，初始状态都是备机。只要与中介断开连接，就将自己降级位备机
* 主机与中介断开后，中介可以立刻告知备机，备机将自己升级为主机
* 若是网络问题，网络恢复后旧主机一新备机的身份向中介上报自己
* 若是掉电重启，旧主机初始状态为备机，并保持自己的备机状态不变
* 主备机与中介连接都正常时，按照实际的状态决定是否进行切换

##### 代价
* 如何实现中介本身的高可用
* 若中介自己宕机了，整个系统就会进入双备机的状态

##### 开源方案
* ZooKeeper 
* Keepalived

#### 模拟式
##### 实现
1. 主备机之间并不传递任务状态数据
2. 备机模拟成一个客户端，向主机发起模拟的读写目标
3. 备机根据读写操作的响应情况来判断主机状态

##### 优点
* 实现更加简单

##### 缺点
* 获取的状态信息只有响应信息
* 基于有限的状态来做决策，可能会出现偏差


### 主主复制
#### 实现
1. 两台机器都是主机，相互将数据复制给对方
2. 客户端可以任意挑选一台进行读写操作

#### 特点
* 两台都是主机，不存在切换的问题
* 客户单无须区分不同角色的主机

#### 缺点
* 必须保证数据能够双向复制，而很多数据都是不能双向复制的

#### 适用场景
* 临时性，可丢失，可覆盖的数据场景


### 数据集群

#### 数据集中集群
* 该结构与主备，主从相似
* 数据只能往主机中写，读操作可以灵活多变

##### 复杂度
* 主机如何将数据复制给多台备机
* 备机如何检测主机状态
* 主机故障后，如何决定新的主机

##### 开源方案
* ZooKeeper


#### 数据分散集群
* 每台服务器都负责存储一部分数据
* 每台服务器又会备份一部分数据

##### 复杂度
* 均衡性：保证数据分区基本是均衡的
* 容错性：服务器故障时，能切换请求
* 可伸缩性：扩充新服务器后，可以将部分数据迁移到新服务器

##### 开源方案
* Hadoop


### 数据分区
* **基于地理级别的故障来设计高可用架构**



## 接口级的故障
* **指系统没有宕机，网络也没有中断，但业务却出现问题**

### 原因
* 内部原因：程序bug, 数据库的慢查询
* 外部原因：黑客攻击，促销，第三方系统大量请求

### 解决方法
* 思想：优先保证核心业务和优先保证绝大部分用户

#### 降级
* 系统将某些业务或接口功能降低（只提供部分功能，完全停止所有功能），优先保证核心业务
* 目的：应对系统自身的故障

##### 系统后门降级
* 系统预留后门用于降级操作

###### 优点
* 实现成本低

###### 缺点
* 如果服务器数量多，操作效率比较低

##### 独立降级系统
* 将降级操作独立到一个单独的系统中
* 实现复杂的权限管理、批量操作


#### 熔断
* **目的：应对依赖的外部系统故障的情况**

##### 实现关键
* 有一个统一的API调用层，来进采样或统计
* 阀值的设计，先分析确定只，后上线调优


#### 限流
* 只允许系统能够承受的访问量进行，超出系统访问能力的请求将被丢弃
* **从客户访问压力的角度来考虑如何应对故障**

##### 基于请求限流
* 限制总量：限制某个指标的累积上限。比如：当前系统服务的用户总量
* 限制时间量：限制一段时间内某个指标的上限

###### 优点
* 实现简单

###### 难点
* 很难找到合适的阀值


##### 基于资源限流
* 找到系统内部影响性能的关键资源，对其上限进行限制
* 比如：连接数、文件句柄、线程数、请求队列

###### 优点
* 更有效地反映系统当前的压力

###### 难点
* 如何确定关键资源
* 如何确定阀值



#### 排队
* 限流的一种变种
* 不直接拒绝用户，让用户等待一段时间



## 可扩展架构

### 基本思想
* **拆**: 将原本大一统的系统拆分成多个规模小的部分，扩展时只修改其中一部分即可

### 基本思路
* 面向流程拆：将整个业务流程拆分为几个阶段，每个阶段作为一部分
* 面向服务拆：将系统提供的服务拆分，每个服务作为一部分
* 面向功能拆：将系统提供的功能拆分，每个功能作为一部分
* **范围：流程 》 服务 》 功能**


#### 实例

#### TCP/IP协议
##### 流程
* 网络通信流程：应用层 --》传输层 --》网络层  --》物理+数据链路层

##### 服务
应用层服务包括：
* HTTP 提供web服务
* FTP  提供文件服务
* SMTP 提供邮件服务

##### 功能
* HTTP 提供 GET, POST功能
* FTP 提供上传、下载功能
* SMTP 提供邮件发送，邮件收取功能


#### 学生信息管理系统
##### 流程
* 展示层 --》业务层 --》数据层 --》存储层

##### 服务
* 注册、登录、信息管理、安全设置

##### 功能
* 注册：手机号注册、身份证注册
* 登录：手机登录、身份证登录
* 信息管理：基本信息、课程信息、成绩信息


#### 扩展方式
* **不同的拆分方式，本质上决定了系统的扩展方式**
* 面向流程拆：分层架构
* 面向服务拆：SOA，微服务
* 面向功能拆：微内核



### 分层架构
**核心：需要保证各层之间的差异足够清晰，边界足够明显**

#### 种类
##### C/S、B/S架构
* 划分对象：整个业务系统
* 划分维度：用户交互
* 将和用户交互的部分独立为一层，支撑用户交互的后台作为另外一层

##### MVC、MVP架构
* 划分对象：单个业务子系统
* 划分维度：职责
* 将不同职责划分到独立层，各层的依赖关系比较灵活

##### 逻辑分层架构
* 划分对象：单个业务子系统
* 划分维度：职责
* 各层是自顶向下依赖的


#### 特点
##### 关注点隔离
* 每个层中的组件只会处理本层的逻辑
* 较好的支持系统扩展

##### 保证层间依赖是稳定的
* 支持系统的快速扩展

##### 层层传递
* 整个业务流程是按照层进行依次传递的，不能在层之间进行跳跃


### SOA
* 面向服务的架构
* 为了解决企业内部IT系统重复建设且效率低下的问题

#### 现存问题
* 各个部门有独立的IT系统
* 各个独立的IT系统可能采购于不同的供应商，实现技术不同
* 随着业务发展，复杂度越来越高

#### 解决方法
* 服务：所有业务功能都是一项服务，需要对外提供开放的能力
* ESB：企业服务总线，屏蔽异构系统对外提供各种不同的接口，来使服务间高效的互连互通
* 松耦合：减少各个服务间的依赖和相互影响

#### 问题
* ESB过于复杂，导致本身成为整个系统的性能瓶颈


### 微服务
#### 对比SOA
* **本质区别：small、lightweight、automated**

##### 服务粒度
* SOA的服务粒度要粗一点
* 微服务的服务粒度要细一点

##### 服务通信
* SOA采用ESB作为通信组件，实现服务定义、服务路由、消息转换，消息传递
* 微服务使用统一的协议和格式

##### 服务交付
* SOA无特殊要求，更多考虑的是兼容已有的系统
* 微服务要求‘快速交付’，相应的要采用自动化测试、持续集成、自动化部署

##### 应用场景
* SOA适合于庞大、复杂、异构的企业级系统
* 微服务适合于快速、轻量级、基于Web的互联网系统


#### 陷阱
 * 服务划分过细，服务间关系复杂
 * 服务数量太多，团队效率急剧下降
 * 调用链太长，性能下降
 * 调用链太长，问题定位困难
 * 没有自动化支撑，无法快速交付
 * 没有服务治理，数量多了后管理混乱


#### 最佳实践-方法
##### 服务粒度
* **基于团队规模进行拆分**
* 三个火枪手：一个微服务有三个人进行负责开发

##### 拆分方法
###### 基于业务逻辑
* 将系统中的业务模块按照**职责范围**识别出来
* 每个单独业务模块拆分成一个独立的服务
* 使用‘三个火枪手’原则来确定拆分规模

###### 基于可扩展
* 将系统中的业务模块按照**稳定性排序**
* 将已成熟和改动不大的服务拆分为稳定服务，经常变化和迭代的服务拆分为变动服务
* 稳定服务粒度可以粗一点
* 变动服务粒度可以细一点

###### 基于可靠性
* 将系统中的业务模块按照**优先级排序**
* 将可靠性要求高的核心服务和可靠性要求低的非核心服务拆分开来
* 重点保证核心服务的高可用

###### 基于性能
* 将系统中的业务模块按照**优先级排序**
* 将性能要求高的，性能压力大的模块拆分出来

##### 基础设施
* **决定了微服务的成败**
* 按照优先级来搭建基础设施
    * 基本服务：服务发现、服务路由、服务容错
    * 提升开发效率：接口框架、API网关
    * 提升测试、运维效率：自动化部署、自动化测试、配置中心
    * 进一步提升运维效率：服务监控、服务跟踪、服务安全



#### 最佳实践-基础设施
##### 自动化测试
* 单元测试
* 单个系统的集成测试
* 系统间的接口测试

##### 自动化部署
* 版本管理
* 资源管理
* 部署操作
* 回退操作

##### 配置中心
* 配置版本管理
* 增删改查配置
* 节点管理
* 配置同步
* 配置推送

##### 接口框架
* 统一接口协议
* 统一接口传递的数据格式

##### API网关
* 用于负责外部系统的访问操作
* 包括：接入鉴权、权限控制、传输加密、请求路由、流量控制

##### 服务发现
* 用于支撑微服务的自动注册和发现
* 实现方式：自理式和代理式
* 核心功能：服务注册表

##### 服务路由
* 和服务发现一起实现
* 核心功能：路由算法
* 算法：随机路由、轮询路由、最小压力路由、最小连接数路由

##### 服务容错
* 求重试
* 流控和服务隔离

##### 服务监控
* 实时搜集信息并进行分析，避免故障后再来分析
* 可以在实时分析的基础上进行预警，在问题萌芽的阶段发觉并预警

##### 服务跟踪
* 用于跟踪单次请求的信息

##### 服务安全
* 接入安全、数据安全、传输安全



### 微内核
* 插件化架构，是一种面向功能进行拆分的可扩展性架构

#### 基本架构
* **包括：核心系统和插件模块**
* 核心系统负责和具体业务功能无关的通用功能
* 插件模块负责实现具体的业务逻辑

#### 设计关键点
* **插件管理** 常见的实现方法是插件注册表机制
* **插件连接** 常见的连接机制有 OSGi，消息模式、依赖注入
* **插件通信**


#### OSGi架构
* **OSGi是一个插件化的标准，不是一个框架**
* 框架：Eclipse的Equinox，Apache 的 Felix、Spring 的 Spring DM

##### 逻辑架构
###### 模块层(Module 层)
* 实现了插件管理的功能
* 每个插件被称为一个Bundle
* 每个 Bundle 是一个 Java 的 JAR 文件
* 包含一个元数据文件 MANIFEST.MF

###### 生命周期层(Lifecycle 层)
* 实现了插件连接的功能
* 定义了 Bundle 生命周期的操作（安装、更新、启动、停止、卸载）

###### 服务层（Service 层）
* 实现了插件通信的功能


#### 规则引擎
* 执行引擎可以看作是微内核
* 执行引擎解析配置好的业务流，执行其中的条件和规则


### 互联网架构模块 - 存储层技术

#### SQL
* 一般都使用MySQL、PostgreSQL 等开源数据库
* 拆分数据库用于满足性能要求：MySQL Router，Atlas
* SQL集群

#### NoSQL

#### 小文件存储
* 数据小，一般在1MB以下
* 数量巨大
* 访问量巨大

#### 大文件存储
* 业务上的大数据

### Hadoop生态
![](https://gitee.com/cc12703/figurebed/raw/master/img/20201130121021.png)









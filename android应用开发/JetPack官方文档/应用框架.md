
# 应用框架

## 用户体验
* 一个桌面应用，只有一个单一入口点，以一个单一的，巨大的进程运行
* 一个android应用，包含多个应用组件：activiy, fragment, service, content-provider, broadcast-receiver


### 定义
* 可以在应用manifest文件中定义大部分应用组件
* androidOS会使用该文件来决定如何整合应用进系统，以构成完整的用户体验

### 例子
**在流行的社交应用上分享照片**
1. 应用发起摄像意愿，系统会启动一个摄像头应用
2. 用户已经离开社交应用，但是用户体验没有中断
3. 摄像头应用会发起其他意愿，像启动文件选择器
4. 最终用户会回到社交应用并分享图片

### 中断
* 在上面的流程中，用户可能会被电话或通知打断
* 在被打断后，用户希望能够恢复并回到原来的流程中
* 在应用设备上，这种应用跳转是比较常见的

### 资源受限
* 记住移动设备是资源受限的
* 任何时候系统都会杀死一些应用进程，给新应用腾出空间

#### 后果
* 应用组件会被独立的调起，并且是乱序的
* OS和用户会在任何时间销毁这些组件

#### 注意点
* 不要在应用组件中存储任何应用数据和状态
* 应用组件不要相互依赖


## 通用原则


### 关注点分离
* 这个是最重要的一个原则
* 一个通常错误就是在activity或fragment中写所有的代码
* 这些类通常只用来包含处理界面和系统交互的逻辑

#### 注意点
* 你不拥有activity和fragment的实现
* 这些只是胶水类，用于保证系统和应用之间契约
* 系统可以在任何时间销毁他们
* 保持这些类尽可能的小，可以避免许多生命周期相关的问题


### 模型驱动界面
* 使用模型来驱动界面，特别是持久化模型
* 模型是一些组件用于处理应用的数据
* 他们独立于View对象和应用组件，不会受应用生命周期的影响


#### 持久化优势
* 用户不会丢失数据，当系统因为释放资源而销毁应用
* 应用可以继续运行，当在网络无效时、变弱时


## 推荐架构

### 架构图
![](https://gitee.com/cc12703/figurebed/raw/master/img/20201111113003.png)

#### 注意点
* 每个组件只依赖在自己下面一层的组件
* 该架构可以创建出一个持续的、令人愉悦的用户体验
    * 当用户关闭应用一段时间后重新打开，会看到保存在本地的用户信息
    * 如何用户信息过期，应用repository模块会在后台开始更新数据


### 构建用户界面

* 界面包括一个framgent：UserProfileFragment
* 对应的布局文件：user_profile_layout.xml
* 数据模型需要保存以下数据项
    * UserID 用户标识
    * UesrObject 用户详情信息

#### 定义文件
* user_profile.xml 界面布局信息
* UserProfileFragment 界面控制器
* UserProfileViewModel 准备数据、处理用户交互


#### 创建核心模块

* 使用SavedState模块，可以让ViewModel直接从fragment的参数中获取数据
* 使用LiveData，可以在user对象获取到时，通知fragment


```kotlin
class UserProfileViewModel(
    savedStateHandle: SavedStateHandle
) : ViewModel() {
   val userId : String = savedStateHandle["uid"] ?:
          throw IllegalArgumentException("missing user id")
   val user : LiveData<User> = TODO()
}


class UserProfileFragment : Fragment() {
   
   private val viewModel: UserProfileViewModel by viewModels(
       factoryProducer = { SavedStateVMFactory(this) }
   )

   override fun onCreateView(
       inflater: LayoutInflater, container: ViewGroup?,
       savedInstanceState: Bundle?
   ): View {
       return inflater.inflate(R.layout.main_fragment, container, false)
   }

   override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
                super.onViewCreated(view, savedInstanceState)
        viewModel.user.observe(viewLifecycleOwner) {
            // update UI
        }
    }
}
```

### 获取数据

* 使用Retrofit库来访问后端数据
* 创建Repository模块来处理数据操作
    * 给其他模块提供了一个干净的对外接口
    * 作为不同数据源的中介：持久化模块、web服务器、缓存


```kotlin
interface Webservice {

   @GET("/users/{user}")
   fun getUser(@Path("user") userId: String): Call<User>
}

class UserRepository {
   private val webservice: Webservice = TODO()
   
   fun getUser(userId: String): LiveData<User> {
       val data = MutableLiveData<User>()
       webservice.getUser(userId).enqueue(object : Callback<User> {
           override fun onResponse(call: Call<User>, response: Response<User>) {
               data.value = response.body()
           }
           
           override fun onFailure(call: Call<User>, t: Throwable) {
               TODO()
           }
       })
       return data
   }
}

```


# 区块链原理设计与应用

[TOC]

## 数字货币

### 去中心化的难点
* 货币的防伪：如何鉴定货币的真伪
* 货币的交易：如何使货币安全的转移
* 避免双重支付：如何避免同一份货币支付给多个接收者

### 比特币
**首次真正从实践意义上实现了安全可靠的去中心化数字货币机制**

* 使用分布式网络，无需任何管理机构
* 通过数学和密码学来确保所有交易的成功进行
* 自身的价值通过背后的计算力进行背书
* 使用区块链结构实现了账本功能

### 区块链特点
* 分布式容错性
* 不可篡改性：一致提交后的数据会一直存在，不可被修改或销毁
* 隐私保护性：使用密码学


## 核心技术

### 基本原理
#### 概念
* 交易：一次对账本的操作，导致账本状态的一次改变
* 区块：记录一段时间内发生的所有交易和状态结果，是对当前账本状态的一次共识
* 链：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录

#### 要点
* 一个分布式的数据记录账本
* 账本只允许添加，不允许删除
* 账本底层是一个线性的链表，由一个个’区块‘串联组成
* 后续区块会记录前导区块的哈希值

#### 工作流程
1. 客户端发起一项交易，广播到网络中等待确认
2. 节点会收集这些待确认交易，组成一个候选区块
3. 节点会尝试找到一个nonce串，使候选区块的哈希值满足一定的条件
4. 节点将合法区块广播到网络中
5. 其他节点收到区块后会验证该区块，若合法则将其添加到本地的区块链中
6. 当大部分节点都添加了改区块后，该交易就得到确认

#### Pow
* Proof of Work 工作量证明
* 是一种共识机制
* 寻找nonce串只能通过尝试性的暴力计算

#### 分布式记账
* 区块链是首个自带对账功能的数字记账技术实现
* 维护一条不断增长的链，只能添加记录，不能篡改记录
* 去中心化
* 通过密码学机制来确保交易无法被抵赖和破坏

### 区块链分类
* 公有链
* 私有链
* 联盟链

### 关键问题

#### 抗抵赖和隐私保护
* 使用密码学的手段：hash算法、加解密算法、数字证书、签名

#### 分布式共识
* 公开匿名场景下，基于概率的算法
* 带权限管理，基于确定性的算法

#### 交易性能
* 不适用于高频次的交易
* 性能很大程度上取决于单个节点的处理能力

#### 提升手段
* 提升单个节点的性能，优化策略和算法
* 将大量高频的交易放到链外进行，只有区块链记录最终交易信息

#### 扩展性
* 无法简单的通过增加节点来扩展系统的处理能力
* 根本点是放松对每个节点都必须参与完整处理的限制

#### 安全防护
* 立法，如何进行监管
* 软件实现的漏洞
* 公有链的所有交易记录都是公开的

#### 存储系统
* 区块链网络有大量信息需要写到文件和数据库中
* 包含大量的读写操作、hash计算、验证操作


### 误区
* 区块链不等于数据库
* 要解决的核心问题是多方的互信问题


## 分布式系统的核心问题

### 一致性问题
#### 总体
* **一致性指系统对外呈现的状态是否一致**
* 基础思路：将可能引发不一致的并发操作进行串行化
* 核心秘诀：把多件事情进行排序，而且这个顺序还得是大家认可的

#### 要求
* 可终止性：一致的结果在有限时间内完成
* 约同性：不同节点最终完成决策的结果是相同的（任何给出的结果必定是达成共识的）
* 合法性：决策的结果必须是某个节点提出的提案


#### 分类
##### 强一致性
* 顺序一致性
* 线性一致性
* **实现强一致性往往需要准确的计时设备**

##### 弱一致性
* 最终一致性


### 共识算法
* 一致性描述的是结果状态，共识则是一种手段
* 要解决的是对某个提案大家达成一致意见的过程
* 核心是对多个事件顺序进行共识，即排序（状态机复制问题）

#### 问题
* 非拜占庭错误：节点出现故障，但不会伪造信息
* 拜占庭错误：节点会伪造信息

#### 算法
* CFT类算法：处理非拜占庭错误，像Paxos, Raft
* BFT类算法：处理拜占庭错误，像 PBFT, PoW

#### FLP不可能原理
* 在网络可靠，但允许节点失效的最小化**异步**模型系统中
* 不存在一个可以解决一致性问题的确定性共识算法

##### 异步含义
* 各个节点可能存在较大的时钟差异
* 消息传输时间是任意长的
* 各个节点处理消息的时间也可能是任意长的



### CAP原理
* 系统不可能同时确保以下三个特性：一致性，可用性，分区容忍性
* 设计时需要弱化对某个特性的保证

#### 特性
* 一致性：任何操作应该都是原子的
* 可用性：在有限时间内，任何非失败节点都能应答请求
* 分区容忍性：网络可能发生分区，节点之间的通信无法保障

#### 含义
* 当网络出现分区时，系统是无法同时保证一致性和可用性的

#### 场景
* 弱化一致性：Gossip协议、CouchDB、Cassandra
* 弱化可用性：MongoDB, Redis, MapReduce, Paxos, Raft
* 弱化分区容忍性：两阶段提交、ZooKeeper

#### 应用
* ACID原则：牺牲掉一定的可用性，来换取一致性需求
* BASE原则：牺牲掉对一致性的约束（实现最终一致性），来换取一定的可用性 



### Paxos算法
#### 总体
* 最大化保障一致性
* 第一个广泛应用的共识算法
* 基于 两阶段提交 算法
* 通过消息传递来逐步消除系统中的不确定状态

#### 角色
* Proposer：提出一个提案，等待被批准，每个提案都有一个唯一提案号
* Acceptor: 负责对提案进行投票，接受提案
* Learner: 获取批准结果，并帮忙传播

#### 约束
* Safety : 保存决议结果是对的，无歧义，不会出现错误情况
* Liveness : 保证决议过程能在有限时间内完成

#### 流程
1. 多个提案者先争取提案权利（大部分接受者的支持）
2. 有权利的提案者发生提案给所有人确认
3. 得到大部分人确认的提案成为批准的结案

#### 两阶段提交
##### 准备阶段
**通过锁来解决对哪个提案内容进行确认的问题**
1. 提案者发生自己的提案编号给多个接收者
2. 接收者保留收到提案的最大编号和接受的最大提案
3. 接收者只接收编号大的提案
4. 接收者接收提案后，会返回已接受的提案编号（或空）

##### 提交阶段
**解决大多数确认最终值的问题**
1. 提案者若收到大多数的回复，则准备发送‘接受消息’
    1. 若回复中没有新的提案，则使用自己的提案
    1. 若回复中有提案，则使用回复中编号最大的提案
2. 提案者没有收到足够多的回复，则再次发出请求
3. 接受者收到‘接受消息’，需要检查提案号
    1. 若提案号大于等于已接受最大提案号，则接受该提案
   
   
**一旦多数接受者接受了共同的提案值，则形成决议**



### Raft算法
#### 角色
* Leader(领导者）
* Candidate(候选者）
* Follower(跟随者）

#### 流程
1. 选举出一个Leader
2. Leader进行日志同步
3. Leader负责从客户端接收log，分发到其他节点

##### Leader选举
* 开始时所有节点都是Follower，定时接收Leader或Candidate的消息
* 在随机超时后未收到定时消息，就转换成Candidate
* 提出选举请求，在一个选举期得票过半的成为Leader

#### 同步日志
* Leader查找系统中日志最新的记录
* Leader强制所有的Follower来刷新到这个记录



### PBFT算法
#### 总体
* 将算法复杂度降到到了多项式级别
* 使用密码学技术来确保消息传递过程无法被篡改和破坏

#### 流程
* 通过其他算法，选出一个主节点。称为一个视图(view)
* 在一个视图中，客户端将请求发送给主节点，由其广播给其他副本节点
* 所有节点处理完成请求，将结果发送给客户端。
* 客户端检查是否收到了至少f+1个来自不同节点的相同结果

#### 广播流程
##### 预准备
* 主节点为请求分配提案编号
* 发送预准备消息给各个副本节点

###### 消息格式
> <<PRE-PREPARE, view, n, digest>, message>

##### 准备
* 副本节点接收到预准备消息后，检查是否合法
* 若合法则向其他节点发送准备消息，同时接收其他节点的准备消息
* 接收到准备消息后，检查是否合法
* 若合法则将准备消息写入消息日志
* 集齐至少2f+1个验证过的消息，才进入准备状态

###### 消息格式
> <PREPARE, view, n, digest ,id>

##### 提交
* 广播commit消息，告诉其他节点提案n在视图v中已经处于准备状态
* 集齐至少2f+1个验证过的commit消息，则提案通过


### PoW算法
* 一种概率算法
* 限制了一段时间内全网中出现提案的个数（增加提案成本）
* 放宽了对最终一致性确认的要求（约定只在最长的链上进行扩展）



## 密码学

### hash算法
* **将任意长度的数据映射为较短的固定长度的二进制串**

#### 特性
* 正向快速
* 逆向困难：在有限时间内很难（基本不可能）逆推出明文
* 输入敏感：输入信息发生一点变化，输出应该会出现很大不同
* 冲突避免：很难找到两段不同的明文，输出的值是一样的

#### 常见算法
* MD5
* SHA系列 （推荐使用SHA2-256）

#### 性能
* 一般都是计算敏感型的
* 有一些算法是内存敏感型的

#### 应用
* 数字摘要：使用hash值来指代原始内容，可以确保内容未被篡改过
* 口令保存：保存的是 hash(口令明文 + 随机字符串) 值


### 对称加密算法
* 加密和解密都使用相同的密钥

#### 特性
* 加解密效率高（速度快，空间占用小）
* 加密强度高
* 缺点是需要提前持有密钥

#### 分类
* 分组密码：将明文分成定长的数据块作为基本加解密单元
* 序列密码：每次只对一个字节进行加密处理，且密码不断变化


### 非对称加密算法
* 加解密的密钥是不一样的。加密密钥为公钥，解密密钥为私钥

#### 特性
* 公私钥分离，公钥一般是公开的。
* 缺点：处理速度比较慢（相对于对称算法）
* 安全性基于数学问题来保障的

#### 算法
* RSA: 利用对大数进行质因子分解困难
* DH密钥交换: 基于离散对数无法快速求解
* SM2：基于椭圆曲线

#### 场景
* 签名
* 密钥协商


### 混合加密机制
* 使用非对称加密协商一个临时的对称加密密钥
* 再使用对称加密对传递的大量数据进行处理

#### HTTPS
* 混合加密的一个应用案例
* 在HTTP层和TCP层之间引入了TLS/SSL加密层

##### 建立安全连接流程
1. 浏览器发送信息到服务器，明文（随机数R1，支持的加密算法类型，协议版本，压缩算法
2. 服务器返回信息，明文（随机数R2，选定的加密算法类型，协议版本，服务器证书
3. 浏览器检查服务器的证书
4. 客户端用证书中公钥加密随机数R3，发送给服务器
5. 双方通过伪随机数函数来生成对称会话密钥（MasterSecret)
6. 服务器和客户端的通信都通过对称加密算法进行保护

##### 注意点
* 该过程的主要功能是在防止中间人窃听和篡改的前提下完成会话密钥的协商
* TLS对每个会话连接都可以生成不同的秘钥


### 消息认证码
* 全称：基于Hash的消息认证码
* 基于对称加密实现的
* 可以用于对消息完整性进行保护
* 一般用于证明身份的场景

#### HMAC值
* 包括(K，H，Message）三个因素
* K 提前共享的对称密钥
* H 提前商定的hash算法
* Message 要处理的消息内容

#### 问题
* 需要共享密钥


### 数字签名
#### 总体
* 基于非对称加密
* 可以证实内容的完整性
* 可以确认来源

#### 流程
##### 发送者
1. 获取要发送内容的摘要
2. 使用私钥对摘要进行加密（签名）
3. 将内容和签名同时发送

##### 接收者
1. 使用发送者的公钥来解密签名，得到摘要
2. 获取接收到内容的摘要
3. 对比两个摘要是否一致

#### 盲签名
* 签名者在无法看到原始内容的前提下对信息进行签名
* 实现对所签名内容的保护，防止签名者看到原始内容
* 实现防止追踪

#### 多重签名
* N个签名者中，收集到至少M个的签名，才认为合法
* 可以有效地被应用在多人投票共同决策的场景

#### 群签名
* 某个群组内的一个成员可以代表群组进行匿名签名

#### 环签名
* 是一种简化的群签名，用于保护匿名性
* 选定一个临时的签名者集合，集合中包含签名者自身
* 利用自己的私钥和集合中其他人的公钥，独立的产生签名

#### 安全性
* 需要选取合适的随机数作为配置参数


### 数字证书
#### 总体
* 用于解决公钥分发的问题
* 颁发者需要对证书内容利用自己的公钥添加签名

#### 类型
* 加密数字证书：用于保护加密信息的公钥
* 签名验证数字证书：用于保护身份验证的公钥

#### X.509
##### 证书规范
* 版本号
* 序列号：由CA维护的证书唯一编号
* 签名算法
* 颁发者
* 颁发者唯一号
* 有效期：有效期限，包括起止时间
* 主体：证书拥有者的标识信息
* 主体的公钥信息（算法、值）
* 主体唯一号

##### 证书格式
* PEM格式：文本，包括首尾标记和内容块
* DER格式：二进制

##### 证书信任链
* 从预先信任的根证书，经过中间层证书，到最底层的实体证书

#### PKI体系
* 用于解决证书生命周期相关的认证和管理问题
* 是一个通用框架：实现安全可靠的消息传递和身份确认

##### 组件
* CA：负责证书的颁发和作废，接收来自RA的请求
* RA：对用户身份进行验证，校验数据合法性，负责登记
* 证书数据库：存放证书

##### 证书的签发
**CA使用自己的私钥对用户的公钥进行签名**

1. 用户先生存一个私钥和证书申请文件(csr)
2. csr包括用户的公钥和基本信息
3. CA对csr进行签名，生成证书文件


##### 证书的撤销
* **CA是无法强制收回已颁发的数字证书**
* 超出有效期
* 用户主动申请


### Merkle树
#### 总体
* 是一个二叉树（根节点、中间节点、叶节点组成）
* 叶节点保存数据或哈希值
* 非叶节点保存其两个孩子节点内容的哈希值
* 根节点值代表了底层所有数据的 ’数字摘要‘

#### 用途
##### 快速比较大量数据
* **优点：hash计算和构建树可以快速完成**
* 对每组数据排序后构建merkle树
* 比较两颗树的根是否相同

##### 快速定位修改
* 从根节点开始定位，最多通过O(logN)时间即可定位到内容

##### 零知识证明
* 在不暴露其他内容的情况下，向他人证明拥有的某部分数据


### 布隆过滤器
#### 总体
* 是一种基于hash的高效查找结构
* 可以快速得到 某个元素是否在一个集合内
* 使用了多个hash函数来提高空间利用率

#### 构造
* 对于同一输入，多个hash函数计算出多个地址
* 分别位串的这些地址上标记为1

#### 查找
* 对输入进行同样的计算
* 查看对应地址上的标记是否为1
* 如何标记都为1，则大概率存在该输入


### 同态加密
* 一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果

#### 特点
* 保证处理者无法访问到数据自身的信息

#### 分类
* 全同态：实现加、减、乘、除四种操作
* 特定同态：实现部分特定的操作

#### 全同态
* 基于理想格的方案
* 基于整数上近似GCD问题的方案
* 基于扰动学习问题的方案



## 比特币
### 特点
* 去中心化：任何交易请求都需要大多数参与者的共识
* 匿名性：账户地址是匿名的
* 通胀预防：发行需要通过挖矿计算来进行

### 设计
* 是一个分布式的点对点网络
* 矿工通过’挖矿‘来完成对交易记录的记账过程
* 提供一个公共可见的记账本，记录了发生过的交易的历史信息

#### 概念
##### 账户地址
* 用户公钥经过一系列hash及编码运算后生成的160位字符串

##### 交易
###### 交易信息
* 付款人地址
* 付款人对交易的签字确认
* 付款人资金的来源交易ID
* 交易的金额
* 收款人地址
* 收款人的公钥
* 时间戳：交易何时能生效

###### 交易检查
* 交易是否已经处理过
* 交易是否合法
* 交易的输入之和是否大于输出之和


##### 交易脚本
* 脚本是保障交易完成的核心机制，当所依附的交易发生时被触发
* 输出脚本：由付款方设置的锁定条件，用来对收款方进行权限控制
* 认领脚本：用于证明自己可以满足输出脚本的锁定条件


##### 区块
###### 结构
* 区块大小（4字节）
* 区块头 （80字节）
* 交易个数计数器（1--9字节）
* 所有交易的具体内容

###### 区块头
* 版本号 （4字节）
* 上一个区块头的hash值 （32字节）
* 包含所有验证过的交易的Merkle树根的hash值
* 时间戳
* 难度指标（4字节）
* Nonce：Pow问题的答案


#### 创新设计
##### 避免作恶
* 基于经济博弈原理
* 在一个开发网络中，无法通过技术手段保证每个人都是合作的
* 通过经济博弈来让合作者得到收益，非合作者受到损失和风险
* 比特币通过挖矿的代价（算力消耗）来让参与者合作

##### 负反馈调节
* 矿工越多，系统就越稳定，比特币价值越高，挖到矿的概率会降低
* 矿工减少，系统更容易被攻击，比特币价值降低，挖到矿的概率会提高
* 比特币价格理论上会稳定在一个值上，价格乘以挖到矿的概率，等于矿工的收益预期

##### 共识机制
* 概率共识：基于概率的，随时间逐步增强确认的共识
* 区块共识：按照区块（一组交易）来进行阶段性确认
* 限制提案个数：大量的hash计算和少数的合法结果


#### 挖矿
* 网络中的节点，通过协助生成新区块来获取一定量新增加比特币的过程

##### 过程
1. 打包一个候选新区块：上一个区块的hash值，新的验证过的交易内容，猜测的随机数X
2. 该随机数要让新区块的hash值小于网络中给定的一个数
3. 该数越小，计算出的难度越大
3. 系统会每隔两周调整一次挖矿难度

##### 工作量证明
* 基于hash难题在目前计算模型下需要大量的计算，保证一段时间内系统中只能出现少数合法提案
* 少量提案被用户接收验证后，会在用户认为的最长链上继续计算
* 参数计算的人，如果没有成为首个算出合法nonce值的人，这些成本都将被沉没掉


#### 闪电网络
* 用于解决比特币建议性能差的问题

##### 思路
* 将大量交易放到比特币区块链之外进行
* 只把关键环节放到链上进行确认
* 引入智能合约的思想来完善链下交易

##### RMSC
* 全称：可撤销的顺序成熟度合同
* 类似于 资金池
* 保证两个人之间的直接交易可以在链下完成ß

###### 流程
1. 双方之间存在一个资金池
2. 交易前先预存一部分资金进去
3. 每次发生交易后，需要对交易后的资金分配结果共同进行确认，把旧的分配结果作废掉（双方签名认证）
4. 任何一方需要提现时，就将分配结果写到区块链网络中



##### HTLC
* 全称：哈希的带时钟的合约
* 类似于 限时转账
* 保障了任意两个人之间的转账都可以通过一条’支付‘通道完成


###### 流程
1. 双方约定转账方先冻结一笔钱，并提供一个哈希值
2. 如果在一定时间内，有人能提出一个字符串，其哈希后的值与已知值匹配
3. 则这笔钱转给接收方



#### 侧链
* 允许资产在比特币链和其他区块链之间互转

##### 原理
* 比特币区块链作为主链
* 其他区块链作为侧链
* 两者通过**双向挂钩**，实现比特币从主链转移到侧链进行流通
* 当比特币在侧链流通时，主链上对应的比特币会被锁定

##### SPV证明
* 使用SPV来证明一个动作确实已经在区块链中发生过

###### SPV(简单支付验证）
* 作用：能够以较小的代价判断某个支付交易是否已经被验证过，以及得到了多少算力保护
* 原理：只下载所有区块的区块头，并进行简单的定位和计算工作

###### 内容
* 一组区块头的列表，表示工作量证明
* 一个特定输出确实存在于某个区块中的密码学证明


##### 双向挂钩
* 难点：接受资产的链必须确保发送资产的链上的币被可靠锁定

###### 流程
主链向侧链转移比特币：
1. 在主链上创建交易，要转移的比特币被发往一个特殊的输出，被锁定
2. 等待一段确认期，以获取足够的工作量确认
3. 在侧链上创建交易，输入为主链上被锁定的输出，提供足够的SPV证明
4. 等待一段竞争期，防止双重花费攻击
5. 比特币在侧链上自由流通



#### 热点问题
##### 设计权衡
###### 区块容量（更大容量）
* 好处：带来更高的交易吞吐率
* 坏处：增加挖矿成本，增大存储的代价

###### 出块间隔时间（更短）
* 好处：缩短交易确认时间
* 坏处：导致分叉增多，降低网络可用性

###### 脚本支持程度（更强大的脚本指令集）
* 好处：更多的灵活性
* 坏处：更多的安全风险


##### 分叉
* 比特币区块链在升级时会导致分叉。分成：软分叉、硬分叉

###### 软分叉
* 旧节点仍然能够接受新节点产生的交易和区块
* 旧节点可能不理解新节点产生的一部分数据
* 网络既向后又向前兼容

###### 硬分叉
* 旧节点不接受新节点产生的交易和区块
* 网络只向后兼容，不向前兼容
* 导致一段时间内分出两条链


#### 相关工具
##### 客户端
* 用于和比特币网络进行交互，同时参与网络的维护
* 完整客户端：存储所有的交易历史记录，功能完备
* 轻量级客户端：不保存交易副本，交易需要向别人查询
* 在线客户端：网页模式

##### 钱包
* 存储和保护用户的私钥
* 提供查询余额
* 收发比特币

###### 离线钱包
* 离线存储私钥
* 好处：安全性相对最强
* 坏处：无法直接发送交易，便利性差

###### 本地钱包
* 用本地设备存储私钥
* 好处：可以直接发送交易，便利性强
* 坏处：本地设备存在被攻击风险

###### 在线钱包
* 用钱包服务器存储加密过的私钥
* 好处：易用性强
* 坏处：服务器容易被攻击

###### 多重签名钱包
* 由多方共同管理的一个钱包地址


##### 矿机
* 专门用于挖矿的硬件设备，最重要的特性是提供算力



## 以太坊
### 总体
* 公有区块链平台，将比特币的功能进一步进行了拓展，支持智能合约
* 以太坊区块链底层是一个类型比特币的P2P网络，智能合约运行在网络中的以太坊虚拟机中

### 特点
* 支持图灵完备的智能合约（自带编程语言）
* 选用了内存需求较高的哈希函数（避免矿池攻击）
* 使用了‘叔块’激励机制 （降低矿池优势）
* 减少了区块产生间隔
* 采用账号系统和世界状态
* 通过Gas限制代码执行的指令数（避免循环执行攻击）
* 支持PoW共识算法

### 核心概念
#### 智能合约
* 通过图灵完备的高级语言来开发
* 运行在以太坊虚拟机中
* 接受来自外部的交易请求和事件，触发运行提前编写好的代码逻辑
* 执行结果会对以太坊网络的账本状态进行更新，会经过共识

#### 账户
##### 合约账户
* 存储执行的智能合约的代码，只能被外部账户来调用激活
* 被调用后，其中的智能合约会在矿工处的虚拟机中运行，并消耗一定的燃料

##### 外部账户
以太币拥有者账户，对应到某一公钥，由个人控制

#### 交易
* 从一个账户到另一个账户的消息数据
* 可以是以太币或合约的执行参数
* 是以太坊中执行操作的最小单位

##### 字段
* to：目标账户地址
* value：要转移的以太币数量
* nonce：交易相关字串
* gasPrice：执行交易需要消耗的Gas价格
* startGas：交易消耗的最大Gas值
* signature：签名信息


#### 以太币
* 以太坊网络中的货币
* 用于购买燃料，支付给矿工
* 最小单位是wei
* 可以通过挖矿来生成
* 可以在交易市场直接购买

#### 燃料
* 控制某次交易执行指令的上限
* 每执行一条合约指令会消耗固定的燃料
* 若交易执行未完成时，燃料没有了，合约执行会终止被回滚状态


### 主要设计
* 使用一个隔离的轻量级虚拟机环境，运行智能合约代码
* 智能合约使用图灵完备的高级编程语言进行开发
* 使用了账户的模型，状态可以实时保存到账户里
* 使用了变种的PoW算法，运算时需要消耗大量内存
* 所有交易都要提供交易费用，避免DDoS攻击
* 程序运行指令数通过Gas来限制，避免出现恶意合约
* 未来通过分片机制来提高扩展性


## 超级账本
### 总体
* 面向企业应用场景的开源分布式账本平台
* 由多个面向不同目的和场景的子项目构成
* 社区由 技术委员会、管理董事会、Linux基金会共同领导

### 子项目
* Fabric：区块链的基础核心平台
* BlockchainExplorer：提供web操作界面，查看区块链的状态
* Cello：用于区块链平台的部署和运行时管理
* Indy：提供数字身份管理机制
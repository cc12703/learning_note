
[TOC]


# 编程语言实现模式


## 总述

### 语言应用分类

#### 文件读取器
* 根据输入流建立数据结构
* 例子：配置文件读取器、程序分析工具、class文件载入器

#### 生成器
* 收集内部数据结构中的信息，产生输出
* 例子：对象映射工具、序列化工具、网页生成器

#### 翻译器
* 读取文本或二进制数据，生成同种或不同语言的输出
* 例子：重构工具、代码插桩工具、格式调整器

#### 解释器
* 读入文件、解码、执行指令
* 例子：计算器、Java虚拟机


## 基本解析模式

### 类型
* 文法的递归下降识别器
* LL(1)递归下降词法解析器
* LL(1)递归下降语法解析器
* LL(k)递归下降语法解析器

### LL(1)
* L : 解析器按从左到右的顺序解析输入内容
* L : 下降解析时按从左到右的顺序遍历子节点
* 1：向前看一个元素

### 解析树
* 包含了所有语法信息
* 叶节点是词法单元
* 分支节点是表示式的子结构

### 解析器步骤
1. 预测子句类型
2. 调用函数来匹配子结构、词法单元
3. 若匹配成功，则执行自定义操作

### 文法

#### 定义
* 文法：形式化语言，相当于语言的功能说明书
* 生成器：将文法翻译为解析器的工具

#### 例子
```g4
stat     : returnstat
         | assign
         | ifstat
         ;

returnstat  : 'return' expr ';';
assign      : 'x' '=' expr  ;
ifstat      : 'if' expr 'then'  stat  ;
expr        : 'x'  '+'  '0'
            | 'x'  '<'  '0'
            | '0'
            ;
```


### 递归下降识别器

#### 实现方法
* 在文法对应的类中，每条规则都对应类里的一个方法

```java
public class G extends Parser {
	<<词法单元类型的定义>>
	<<合适的构造函数>>
	<<规则对应的方法>>
}
```

#### 子规则转换
* 规则：<<alt1>> | <<alt2>> | ... | <<altN>>
* 原理：通过测试向前看符号，判断当前识别出的词法单元
* 实现方式1：
```java
if ( <<向前看alt1>> ) { <<匹配alt1>> }
else if ( <<向前看alt2>> ) { <<匹配alt2>> }
...
else if ( <<向前看altN>> ) { <<匹配altN>> }
else <<抛出异常>>
```

* 实现方式2
```java
switch ( <<lookahead-token>> ) {

case <<向前看alt1的词法单元1>> :
case <<向前看alt1的词法单元2>> :
	<<匹配alt1>>
	break;

case <<向前看alt2的词法单元1>> :
case <<向前看alt2的词法单元2>> :
	<<匹配alt2>
	break;

...

case <<向前看altN的词法单元1>> :
case <<向前看altN的词法单元2>> :
	<<匹配altN>
	break;

default: <<抛出异常>>
}
```

#### 子规则操作符

##### 可选规则
* (T)?   转换成条件语句
```java
if ( <<向前看到T>> ) { match(T) }   //没有抛出异常的else子句
```

##### 一个或多个规则
* (T)+   转换成do-while循环
```java
do {
    match(T)
} while( <<先前看到T>> );
```

##### 零个或多个规则
* (T)*   转换成while循环
```java
while ( <<先前看到T>> ) {
   match(T)
}
```

### 递归下降语法解析器

#### 概述
* LL解析策略，需要向前看的集合互不相交时才能使用
* 解析器能力完全取决于其根据向前看符号并做决定的能力
* LL(1)  需要向前看一个词法单元
* LL(k)  需要向前看多个词法单元，使用大小为k的环形缓冲区来实现

#### 回溯解析器

##### 特点
* 为递归下降解析器提供推演机制，能够使用任意数量的向前看符号

##### 思路
1. 依次尝试每个解析选项，一直找到合适的为止
2. 如果能匹配，解析器会回到内容的开头，用正常方式重新解析
3. 如果不能匹配，解析器会放回内容，继续尝试下一个

```java
public void <rule> {
	if (尝试<<alt1>>) {
		匹配<<alt1>>
	}
	else if (尝试<<alt2>>) {
		匹配<<alt2>>
	}
	...
	else if (尝试<<altN>>) {
		匹配<<altN>>
	}
	else throw new Exception()
}
```

##### 核心
* 对词法单元缓冲区的管理

##### 缺点
* 解析速度会很慢，无法实际运用


#### 记忆解析器

##### 特点
* 使用少量内存，记录回溯过程中不完整的解析结果

##### 思路
- 每个文法规则都有自己的记忆映射表
- 记录缓冲区中 每个词法单元的当前状态（未解析、匹配失败、匹配成功）


#### 谓词解析器

##### 特点
* 采用任意的布尔表达式（谓词）来辅助解析

##### 思路
* 谓词能描述语义，确定何时可用某些解析选项

```java
public void <rule> {
	if (尝试<<alt1>> && <<谓词1>> ) {
		匹配<<alt1>>
	}
	else if (尝试<<alt2>> && <<谓词2>> ) {
		匹配<<alt2>>
	}
	...
	else if (尝试<<altN>> && <<谓词N>> ) {
		匹配<<altN>>
	}
	else throw new Exception()
}
```


## 中间表示（IR）

### 概述
* 大部分用的IR都采用树形数据结构
* 具体来说都是AST(抽象语法树)
* AST通常是流水线中不同阶段之间交流信息的途径


### 解析树

* 语法相关的
* 内部节点：记录了所调用的规则
* 叶节点：记录了匹配到的词法单元
* 优点：解析器生成器能自动构建解析树
* 缺点：包含很多无用信息，和具体语法相关


### AST

#### 思想
* 操作符、运算符这类节点映射为子树的根节点
* 其他所有节点都映射为上一类节点的子节点
* 操作符优先级越高，位置就越低

#### 特点
* 紧凑：不包含无用的节点
* 易用：很容易遍历
* 含义清晰：突出操作符、操作对象、及其相互间的关系


#### 同型AST

##### 概述
* 优点：简单
* 缺点：使用不方便

##### 实现
* 所有的AST节点都是相同类型的，使用词法单元的类型来区分节点

```java
public class AST {
	Token token;   //词法单元
	List<AST> children;    //子节点列表
}
```


#### 规范化异型AST  

##### 概述
* 优点： 很容易扩展
* 缺点：需要定义很多的类

##### 实现
* 基于同型AST实现，借助类型系统来区分节点
* 使用规范化的子节点列表

```java
public Class ExprNode extends AST {}
public class AddNode extends ExprNode {}
public class IntNode extends ExprNode {}
```


#### 不规则的异型AST

##### 概述
* 优点：很容易扩展、容易阅读
* 缺点：需要定义很多的类

##### 实现
* 使用不规则列表来表示子节点


### 遍历AST

#### 遍历顺序
* 前序遍历：先访问父节点，再访问子节点
* 中序遍历：本节点的访问排在子节点访问之间
* 后序遍历：先访问子节点，再访问节点本身

#### 发现顺序
* 发现节点一般都使用深度优先搜索（DFS）算法
* 从根节点开始，递归地依次遍历子节点

```java
public void walk() {

	<<前序操作>>
	left.walk();
	<<中序操作>>
	right.walk();
	<<后序操作>>

}
```

#### 内嵌式遍历器
* 在异型树的节点类中定义用来遍历的递归方法
* 优点：最简单，最容易理解
* 缺点：不容易扩展

#### 外部访问者
* 将遍历代码封装在单个访问者类中
* 优点：方便修改访问者
* 缺点：只能对节点进行逐个访问


#### 树文法
* 用于构建外部访问者的方法，使用工具自动生成访问者
* 优点：简洁、形式化
* 缺点：需要写出完整的文法，把遍历和操作混在一起


#### 模式匹配器
* 遍历树，在匹配到指定模式的子树时会执行操作或改写
* 优点：只需要描述所关心的子树模式。不用管树的遍历过程。



## 语义分析

### 符号表
* 难点：如何跟踪和查询符号的信息

#### 关键属性
* 名称：一般使用标识符
* 类别：说明符号属于哪一类（类、方法、变量、标签）
* 类型

#### 作用域

##### 定义
* 有明确界限的代码块

##### 分类
* 单作用域：使用集合来实现
* 多重作用域：使用作用域树来实现

##### 名词
* 上下文：符号所在的作用域及所有的外部作用域
* 作用域栈：作用域树上节点到根之间的每条路径
* 语义环境：解析符号时所使用的作用域栈


#### 数据聚集作用域

##### 定义
* 在作用域外可以使用类似于user.name的代码来访问域中的成员

##### 类型
* 数据聚集的符号表，C中的struct
* 类的符号表

##### 处理前向引用
* 使用扫描两次的方法
* 一次用于定义符号
* 一次用于解析

